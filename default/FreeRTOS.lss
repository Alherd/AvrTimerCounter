
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002c  00800100  000017ec  00001880  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000017ec  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000030e  0080012c  0080012c  000018ac  2**0
                  ALLOC
  3 .debug_aranges 000000c0  00000000  00000000  000018ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000053c  00000000  00000000  0000196c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001b52  00000000  00000000  00001ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000823  00000000  00000000  000039fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000160d  00000000  00000000  0000421d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000003b0  00000000  00000000  0000582c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000bb7  00000000  00000000  00005bdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000deb  00000000  00000000  00006793  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  0000757e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 eb 02 	jmp	0x5d6	; 0x5d6 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d4 e0       	ldi	r29, 0x04	; 4
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ec ee       	ldi	r30, 0xEC	; 236
      7c:	f7 e1       	ldi	r31, 0x17	; 23
      7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
      84:	ac 32       	cpi	r26, 0x2C	; 44
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
      8a:	14 e0       	ldi	r17, 0x04	; 4
      8c:	ac e2       	ldi	r26, 0x2C	; 44
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	aa 33       	cpi	r26, 0x3A	; 58
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 cc 01 	call	0x398	; 0x398 <main>
      9e:	0c 94 f4 0b 	jmp	0x17e8	; 0x17e8 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
      a6:	08 95       	ret

000000a8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
      a8:	10 92 2d 01 	sts	0x012D, r1
      ac:	10 92 2c 01 	sts	0x012C, r1
}
      b0:	08 95       	ret

000000b2 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      b2:	0f 93       	push	r16
      b4:	1f 93       	push	r17
      b6:	cf 93       	push	r28
      b8:	df 93       	push	r29
      ba:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & heapBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
      bc:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
      c0:	80 91 2c 01 	lds	r24, 0x012C
      c4:	90 91 2d 01 	lds	r25, 0x012D
      c8:	98 01       	movw	r18, r16
      ca:	28 0f       	add	r18, r24
      cc:	39 1f       	adc	r19, r25
      ce:	42 e0       	ldi	r20, 0x02	; 2
      d0:	2a 38       	cpi	r18, 0x8A	; 138
      d2:	34 07       	cpc	r19, r20
      d4:	58 f4       	brcc	.+22     	; 0xec <pvPortMalloc+0x3a>
      d6:	82 17       	cp	r24, r18
      d8:	93 07       	cpc	r25, r19
      da:	40 f4       	brcc	.+16     	; 0xec <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
      dc:	ec 01       	movw	r28, r24
      de:	ce 5c       	subi	r28, 0xCE	; 206
      e0:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
      e2:	30 93 2d 01 	sts	0x012D, r19
      e6:	20 93 2c 01 	sts	0x012C, r18
      ea:	02 c0       	rjmp	.+4      	; 0xf0 <pvPortMalloc+0x3e>
      ec:	c0 e0       	ldi	r28, 0x00	; 0
      ee:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
      f0:	0e 94 66 08 	call	0x10cc	; 0x10cc <xTaskResumeAll>

	return pvReturn;
}
      f4:	ce 01       	movw	r24, r28
      f6:	df 91       	pop	r29
      f8:	cf 91       	pop	r28
      fa:	1f 91       	pop	r17
      fc:	0f 91       	pop	r16
      fe:	08 95       	ret

00000100 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     100:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     102:	9c 01       	movw	r18, r24
     104:	2d 5f       	subi	r18, 0xFD	; 253
     106:	3f 4f       	sbci	r19, 0xFF	; 255
     108:	32 83       	std	Z+2, r19	; 0x02
     10a:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     10c:	8f ef       	ldi	r24, 0xFF	; 255
     10e:	9f ef       	ldi	r25, 0xFF	; 255
     110:	94 83       	std	Z+4, r25	; 0x04
     112:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     114:	36 83       	std	Z+6, r19	; 0x06
     116:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     118:	30 87       	std	Z+8, r19	; 0x08
     11a:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
     11c:	10 82       	st	Z, r1
}
     11e:	08 95       	ret

00000120 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     120:	fc 01       	movw	r30, r24
     122:	11 86       	std	Z+9, r1	; 0x09
     124:	10 86       	std	Z+8, r1	; 0x08
}
     126:	08 95       	ret

00000128 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     128:	cf 93       	push	r28
     12a:	df 93       	push	r29
     12c:	ac 01       	movw	r20, r24
     12e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     130:	ec 01       	movw	r28, r24
     132:	29 81       	ldd	r18, Y+1	; 0x01
     134:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     136:	f9 01       	movw	r30, r18
     138:	82 81       	ldd	r24, Z+2	; 0x02
     13a:	93 81       	ldd	r25, Z+3	; 0x03
     13c:	13 96       	adiw	r26, 0x03	; 3
     13e:	9c 93       	st	X, r25
     140:	8e 93       	st	-X, r24
     142:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     144:	89 81       	ldd	r24, Y+1	; 0x01
     146:	9a 81       	ldd	r25, Y+2	; 0x02
     148:	15 96       	adiw	r26, 0x05	; 5
     14a:	9c 93       	st	X, r25
     14c:	8e 93       	st	-X, r24
     14e:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     150:	02 80       	ldd	r0, Z+2	; 0x02
     152:	f3 81       	ldd	r31, Z+3	; 0x03
     154:	e0 2d       	mov	r30, r0
     156:	75 83       	std	Z+5, r23	; 0x05
     158:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     15a:	e9 01       	movw	r28, r18
     15c:	7b 83       	std	Y+3, r23	; 0x03
     15e:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     160:	fa 01       	movw	r30, r20
     162:	72 83       	std	Z+2, r23	; 0x02
     164:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     166:	19 96       	adiw	r26, 0x09	; 9
     168:	5c 93       	st	X, r21
     16a:	4e 93       	st	-X, r20
     16c:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     16e:	80 81       	ld	r24, Z
     170:	8f 5f       	subi	r24, 0xFF	; 255
     172:	80 83       	st	Z, r24
}
     174:	df 91       	pop	r29
     176:	cf 91       	pop	r28
     178:	08 95       	ret

0000017a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     17a:	cf 93       	push	r28
     17c:	df 93       	push	r29
     17e:	9c 01       	movw	r18, r24
     180:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     182:	48 81       	ld	r20, Y
     184:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     186:	8f ef       	ldi	r24, 0xFF	; 255
     188:	4f 3f       	cpi	r20, 0xFF	; 255
     18a:	58 07       	cpc	r21, r24
     18c:	21 f4       	brne	.+8      	; 0x196 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     18e:	f9 01       	movw	r30, r18
     190:	a7 81       	ldd	r26, Z+7	; 0x07
     192:	b0 85       	ldd	r27, Z+8	; 0x08
     194:	10 c0       	rjmp	.+32     	; 0x1b6 <vListInsert+0x3c>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     196:	d9 01       	movw	r26, r18
     198:	13 96       	adiw	r26, 0x03	; 3
     19a:	04 c0       	rjmp	.+8      	; 0x1a4 <vListInsert+0x2a>
     19c:	12 96       	adiw	r26, 0x02	; 2
     19e:	0d 90       	ld	r0, X+
     1a0:	bc 91       	ld	r27, X
     1a2:	a0 2d       	mov	r26, r0
     1a4:	12 96       	adiw	r26, 0x02	; 2
     1a6:	ed 91       	ld	r30, X+
     1a8:	fc 91       	ld	r31, X
     1aa:	13 97       	sbiw	r26, 0x03	; 3
     1ac:	80 81       	ld	r24, Z
     1ae:	91 81       	ldd	r25, Z+1	; 0x01
     1b0:	48 17       	cp	r20, r24
     1b2:	59 07       	cpc	r21, r25
     1b4:	98 f7       	brcc	.-26     	; 0x19c <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     1b6:	12 96       	adiw	r26, 0x02	; 2
     1b8:	ed 91       	ld	r30, X+
     1ba:	fc 91       	ld	r31, X
     1bc:	13 97       	sbiw	r26, 0x03	; 3
     1be:	fb 83       	std	Y+3, r31	; 0x03
     1c0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     1c2:	d5 83       	std	Z+5, r29	; 0x05
     1c4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     1c6:	bd 83       	std	Y+5, r27	; 0x05
     1c8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     1ca:	13 96       	adiw	r26, 0x03	; 3
     1cc:	dc 93       	st	X, r29
     1ce:	ce 93       	st	-X, r28
     1d0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1d2:	39 87       	std	Y+9, r19	; 0x09
     1d4:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     1d6:	f9 01       	movw	r30, r18
     1d8:	80 81       	ld	r24, Z
     1da:	8f 5f       	subi	r24, 0xFF	; 255
     1dc:	80 83       	st	Z, r24
}
     1de:	df 91       	pop	r29
     1e0:	cf 91       	pop	r28
     1e2:	08 95       	ret

000001e4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     1e4:	cf 93       	push	r28
     1e6:	df 93       	push	r29
     1e8:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1ea:	12 96       	adiw	r26, 0x02	; 2
     1ec:	ed 91       	ld	r30, X+
     1ee:	fc 91       	ld	r31, X
     1f0:	13 97       	sbiw	r26, 0x03	; 3
     1f2:	14 96       	adiw	r26, 0x04	; 4
     1f4:	8d 91       	ld	r24, X+
     1f6:	9c 91       	ld	r25, X
     1f8:	15 97       	sbiw	r26, 0x05	; 5
     1fa:	95 83       	std	Z+5, r25	; 0x05
     1fc:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     1fe:	14 96       	adiw	r26, 0x04	; 4
     200:	cd 91       	ld	r28, X+
     202:	dc 91       	ld	r29, X
     204:	15 97       	sbiw	r26, 0x05	; 5
     206:	fb 83       	std	Y+3, r31	; 0x03
     208:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     20a:	18 96       	adiw	r26, 0x08	; 8
     20c:	ed 91       	ld	r30, X+
     20e:	fc 91       	ld	r31, X
     210:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     212:	81 81       	ldd	r24, Z+1	; 0x01
     214:	92 81       	ldd	r25, Z+2	; 0x02
     216:	8a 17       	cp	r24, r26
     218:	9b 07       	cpc	r25, r27
     21a:	11 f4       	brne	.+4      	; 0x220 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     21c:	d2 83       	std	Z+2, r29	; 0x02
     21e:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     220:	19 96       	adiw	r26, 0x09	; 9
     222:	1c 92       	st	X, r1
     224:	1e 92       	st	-X, r1
     226:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
     228:	80 81       	ld	r24, Z
     22a:	81 50       	subi	r24, 0x01	; 1
     22c:	80 83       	st	Z, r24
}
     22e:	df 91       	pop	r29
     230:	cf 91       	pop	r28
     232:	08 95       	ret

00000234 <initialize>:
	0b00000000
};

void initialize()
{
	DDRD = 0b11110111;
     234:	87 ef       	ldi	r24, 0xF7	; 247
     236:	8a b9       	out	0x0a, r24	; 10
	DDRB = 0b10001011;
     238:	8b e8       	ldi	r24, 0x8B	; 139
     23a:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11001111;
     23c:	8f ec       	ldi	r24, 0xCF	; 207
     23e:	87 b9       	out	0x07, r24	; 7
     240:	ea e2       	ldi	r30, 0x2A	; 42
     242:	f4 e0       	ldi	r31, 0x04	; 4

	for(int i = 0;i < 8;i++)
	{
		symbols[i] = SPACE;
     244:	80 ec       	ldi	r24, 0xC0	; 192
     246:	93 e0       	ldi	r25, 0x03	; 3
     248:	81 93       	st	Z+, r24
     24a:	91 93       	st	Z+, r25
{
	DDRD = 0b11110111;
	DDRB = 0b10001011;
	DDRC = 0b11001111;

	for(int i = 0;i < 8;i++)
     24c:	24 e0       	ldi	r18, 0x04	; 4
     24e:	ea 33       	cpi	r30, 0x3A	; 58
     250:	f2 07       	cpc	r31, r18
     252:	d1 f7       	brne	.-12     	; 0x248 <initialize+0x14>
	{
		symbols[i] = SPACE;
	}
}
     254:	08 95       	ret

00000256 <pollButtonsTask>:
		vTaskDelay(displayLetterInterval);
	}
}

void pollButtonsTask()
{
     256:	af 92       	push	r10
     258:	bf 92       	push	r11
     25a:	cf 92       	push	r12
     25c:	df 92       	push	r13
     25e:	ef 92       	push	r14
     260:	ff 92       	push	r15
     262:	0f 93       	push	r16
     264:	1f 93       	push	r17
     266:	cf 93       	push	r28
     268:	df 93       	push	r29
		{	
			PORTB = 0b00000000;
			PORTD = 0b00000000;
	
			currentSymbolIndex = 0;
			displayLetterInterval = 400;
     26a:	20 e9       	ldi	r18, 0x90	; 144
     26c:	a2 2e       	mov	r10, r18
     26e:	21 e0       	ldi	r18, 0x01	; 1
     270:	b2 2e       	mov	r11, r18
			
			vTaskResume(displayTaskHandle);			
		}
		else if((PINC & (1 << S2)) == 0)
		{
			symbols[0] = G;
     272:	9e e1       	ldi	r25, 0x1E	; 30
     274:	c9 2e       	mov	r12, r25
     276:	91 e0       	ldi	r25, 0x01	; 1
     278:	d9 2e       	mov	r13, r25
			symbols[2] = E;
     27a:	86 e1       	ldi	r24, 0x16	; 22
     27c:	e8 2e       	mov	r14, r24
     27e:	81 e0       	ldi	r24, 0x01	; 1
     280:	f8 2e       	mov	r15, r24
			symbols[4] = L;
     282:	0e e0       	ldi	r16, 0x0E	; 14
     284:	11 e0       	ldi	r17, 0x01	; 1
			symbols[6] = O;
     286:	c6 e0       	ldi	r28, 0x06	; 6
     288:	d1 e0       	ldi	r29, 0x01	; 1
{
	int pollButtonInterval = 100;

	while(1)
	{
		if((PINC & (1 << S1)) == 0)
     28a:	35 99       	sbic	0x06, 5	; 6
     28c:	1d c0       	rjmp	.+58     	; 0x2c8 <pollButtonsTask+0x72>
		{	
			symbols[0] = O;
     28e:	d0 93 2b 04 	sts	0x042B, r29
     292:	c0 93 2a 04 	sts	0x042A, r28
			symbols[2] = L;
     296:	10 93 2f 04 	sts	0x042F, r17
     29a:	00 93 2e 04 	sts	0x042E, r16
			symbols[4] = E;
     29e:	f0 92 33 04 	sts	0x0433, r15
     2a2:	e0 92 32 04 	sts	0x0432, r14
			symbols[6] = G;
     2a6:	d0 92 37 04 	sts	0x0437, r13
     2aa:	c0 92 36 04 	sts	0x0436, r12

			displayLetterInterval = s1Interval;
     2ae:	80 91 02 01 	lds	r24, 0x0102
     2b2:	90 91 03 01 	lds	r25, 0x0103
     2b6:	90 93 01 01 	sts	0x0101, r25
     2ba:	80 93 00 01 	sts	0x0100, r24
			
			vTaskResume(displayTaskHandle);			
     2be:	80 91 bc 03 	lds	r24, 0x03BC
     2c2:	90 91 bd 03 	lds	r25, 0x03BD
     2c6:	1f c0       	rjmp	.+62     	; 0x306 <pollButtonsTask+0xb0>
     2c8:	20 91 bc 03 	lds	r18, 0x03BC
     2cc:	30 91 bd 03 	lds	r19, 0x03BD
		}
		else if((PINC & (1 << S2)) == 0)
     2d0:	34 99       	sbic	0x06, 4	; 6
     2d2:	1c c0       	rjmp	.+56     	; 0x30c <pollButtonsTask+0xb6>
		{
			symbols[0] = G;
     2d4:	d0 92 2b 04 	sts	0x042B, r13
     2d8:	c0 92 2a 04 	sts	0x042A, r12
			symbols[2] = E;
     2dc:	f0 92 2f 04 	sts	0x042F, r15
     2e0:	e0 92 2e 04 	sts	0x042E, r14
			symbols[4] = L;
     2e4:	10 93 33 04 	sts	0x0433, r17
     2e8:	00 93 32 04 	sts	0x0432, r16
			symbols[6] = O;
     2ec:	d0 93 37 04 	sts	0x0437, r29
     2f0:	c0 93 36 04 	sts	0x0436, r28

			displayLetterInterval = s2Interval;
     2f4:	80 91 04 01 	lds	r24, 0x0104
     2f8:	90 91 05 01 	lds	r25, 0x0105
     2fc:	90 93 01 01 	sts	0x0101, r25
     300:	80 93 00 01 	sts	0x0100, r24
			
			vTaskResume(displayTaskHandle);
     304:	c9 01       	movw	r24, r18
     306:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <vTaskResume>
     30a:	0d c0       	rjmp	.+26     	; 0x326 <pollButtonsTask+0xd0>
		}
		else
		{	
			PORTB = 0b00000000;
     30c:	15 b8       	out	0x05, r1	; 5
			PORTD = 0b00000000;
     30e:	1b b8       	out	0x0b, r1	; 11
	
			currentSymbolIndex = 0;
     310:	10 92 bf 03 	sts	0x03BF, r1
     314:	10 92 be 03 	sts	0x03BE, r1
			displayLetterInterval = 400;
     318:	b0 92 01 01 	sts	0x0101, r11
     31c:	a0 92 00 01 	sts	0x0100, r10
			
			vTaskSuspend(displayTaskHandle);
     320:	c9 01       	movw	r24, r18
     322:	0e 94 2d 09 	call	0x125a	; 0x125a <vTaskSuspend>
		}
		
		vTaskDelay(pollButtonInterval);
     326:	84 e6       	ldi	r24, 0x64	; 100
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <vTaskDelay>
     32e:	ad cf       	rjmp	.-166    	; 0x28a <pollButtonsTask+0x34>

00000330 <changeSymbolTask>:

void changeSymbolTask()
{
	while(1)
	{
		currentSymbolIndex = (currentSymbolIndex + 1) % 8;
     330:	80 91 be 03 	lds	r24, 0x03BE
     334:	90 91 bf 03 	lds	r25, 0x03BF
     338:	01 96       	adiw	r24, 0x01	; 1
     33a:	68 e0       	ldi	r22, 0x08	; 8
     33c:	70 e0       	ldi	r23, 0x00	; 0
     33e:	0e 94 cd 0b 	call	0x179a	; 0x179a <__divmodhi4>
     342:	90 93 bf 03 	sts	0x03BF, r25
     346:	80 93 be 03 	sts	0x03BE, r24

		vTaskDelay(displayLetterInterval);
     34a:	80 91 00 01 	lds	r24, 0x0100
     34e:	90 91 01 01 	lds	r25, 0x0101
     352:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <vTaskDelay>
     356:	ec cf       	rjmp	.-40     	; 0x330 <changeSymbolTask>

00000358 <displayTask>:

	return 0;
}

void displayTask()
{
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	c0 e0       	ldi	r28, 0x00	; 0
     35e:	d0 e0       	ldi	r29, 0x00	; 0
	int letterLineIndex = 0;
	int displayTaskInterval = 3;

	while(1)
	{
		letterLineIndex = (letterLineIndex + 1) % 8;
     360:	ce 01       	movw	r24, r28
     362:	01 96       	adiw	r24, 0x01	; 1
     364:	68 e0       	ldi	r22, 0x08	; 8
     366:	70 e0       	ldi	r23, 0x00	; 0
     368:	0e 94 cd 0b 	call	0x179a	; 0x179a <__divmodhi4>
     36c:	ec 01       	movw	r28, r24
		PORTB = letterLineIndex;
     36e:	85 b9       	out	0x05, r24	; 5
		PORTD = symbols[currentSymbolIndex][letterLineIndex];
     370:	e0 91 be 03 	lds	r30, 0x03BE
     374:	f0 91 bf 03 	lds	r31, 0x03BF
     378:	ee 0f       	add	r30, r30
     37a:	ff 1f       	adc	r31, r31
     37c:	e6 5d       	subi	r30, 0xD6	; 214
     37e:	fb 4f       	sbci	r31, 0xFB	; 251
     380:	01 90       	ld	r0, Z+
     382:	f0 81       	ld	r31, Z
     384:	e0 2d       	mov	r30, r0
     386:	e8 0f       	add	r30, r24
     388:	f9 1f       	adc	r31, r25
     38a:	80 81       	ld	r24, Z
     38c:	8b b9       	out	0x0b, r24	; 11

		vTaskDelay(displayTaskInterval);
     38e:	83 e0       	ldi	r24, 0x03	; 3
     390:	90 e0       	ldi	r25, 0x00	; 0
     392:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <vTaskDelay>
     396:	e4 cf       	rjmp	.-56     	; 0x360 <displayTask+0x8>

00000398 <main>:
		symbols[i] = SPACE;
	}
}

int main()
{
     398:	ef 92       	push	r14
     39a:	ff 92       	push	r15
     39c:	0f 93       	push	r16
	0b00000000
};

void initialize()
{
	DDRD = 0b11110111;
     39e:	87 ef       	ldi	r24, 0xF7	; 247
     3a0:	8a b9       	out	0x0a, r24	; 10
	DDRB = 0b10001011;
     3a2:	8b e8       	ldi	r24, 0x8B	; 139
     3a4:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11001111;
     3a6:	8f ec       	ldi	r24, 0xCF	; 207
     3a8:	87 b9       	out	0x07, r24	; 7
     3aa:	ea e2       	ldi	r30, 0x2A	; 42
     3ac:	f4 e0       	ldi	r31, 0x04	; 4

	for(int i = 0;i < 8;i++)
	{
		symbols[i] = SPACE;
     3ae:	80 ec       	ldi	r24, 0xC0	; 192
     3b0:	93 e0       	ldi	r25, 0x03	; 3
     3b2:	81 93       	st	Z+, r24
     3b4:	91 93       	st	Z+, r25
{
	DDRD = 0b11110111;
	DDRB = 0b10001011;
	DDRC = 0b11001111;

	for(int i = 0;i < 8;i++)
     3b6:	24 e0       	ldi	r18, 0x04	; 4
     3b8:	ea 33       	cpi	r30, 0x3A	; 58
     3ba:	f2 07       	cpc	r31, r18
     3bc:	d1 f7       	brne	.-12     	; 0x3b2 <main+0x1a>

int main()
{
	initialize();

	xTaskCreate(changeSymbolTask, NULL, 
     3be:	88 e9       	ldi	r24, 0x98	; 152
     3c0:	91 e0       	ldi	r25, 0x01	; 1
     3c2:	60 e0       	ldi	r22, 0x00	; 0
     3c4:	70 e0       	ldi	r23, 0x00	; 0
     3c6:	45 e5       	ldi	r20, 0x55	; 85
     3c8:	50 e0       	ldi	r21, 0x00	; 0
     3ca:	20 e0       	ldi	r18, 0x00	; 0
     3cc:	30 e0       	ldi	r19, 0x00	; 0
     3ce:	03 e0       	ldi	r16, 0x03	; 3
     3d0:	ee 24       	eor	r14, r14
     3d2:	ff 24       	eor	r15, r15
     3d4:	0e 94 a0 0a 	call	0x1540	; 0x1540 <xTaskCreate>
		configMINIMAL_STACK_SIZE, NULL, 3, NULL);

	xTaskCreate(pollButtonsTask, NULL, 
     3d8:	8b e2       	ldi	r24, 0x2B	; 43
     3da:	91 e0       	ldi	r25, 0x01	; 1
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	70 e0       	ldi	r23, 0x00	; 0
     3e0:	45 e5       	ldi	r20, 0x55	; 85
     3e2:	50 e0       	ldi	r21, 0x00	; 0
     3e4:	20 e0       	ldi	r18, 0x00	; 0
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	04 e0       	ldi	r16, 0x04	; 4
     3ea:	0e 94 a0 0a 	call	0x1540	; 0x1540 <xTaskCreate>
		configMINIMAL_STACK_SIZE, NULL, 4, NULL);

	xTaskCreate(displayTask, NULL, 
     3ee:	8c ea       	ldi	r24, 0xAC	; 172
     3f0:	91 e0       	ldi	r25, 0x01	; 1
     3f2:	60 e0       	ldi	r22, 0x00	; 0
     3f4:	70 e0       	ldi	r23, 0x00	; 0
     3f6:	45 e5       	ldi	r20, 0x55	; 85
     3f8:	50 e0       	ldi	r21, 0x00	; 0
     3fa:	20 e0       	ldi	r18, 0x00	; 0
     3fc:	30 e0       	ldi	r19, 0x00	; 0
     3fe:	ec eb       	ldi	r30, 0xBC	; 188
     400:	ee 2e       	mov	r14, r30
     402:	e3 e0       	ldi	r30, 0x03	; 3
     404:	fe 2e       	mov	r15, r30
     406:	0e 94 a0 0a 	call	0x1540	; 0x1540 <xTaskCreate>
		configMINIMAL_STACK_SIZE, NULL, 4, &displayTaskHandle);

	vTaskStartScheduler();
     40a:	0e 94 8f 0b 	call	0x171e	; 0x171e <vTaskStartScheduler>

	return 0;
}
     40e:	80 e0       	ldi	r24, 0x00	; 0
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	0f 91       	pop	r16
     414:	ff 90       	pop	r15
     416:	ef 90       	pop	r14
     418:	08 95       	ret

0000041a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     41a:	fc 01       	movw	r30, r24
unsigned portSHORT usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     41c:	91 e1       	ldi	r25, 0x11	; 17
     41e:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     420:	22 e2       	ldi	r18, 0x22	; 34
     422:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     424:	83 e3       	ldi	r24, 0x33	; 51
     426:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     428:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     42a:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     42c:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     42e:	80 e8       	ldi	r24, 0x80	; 128
     430:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     432:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     434:	82 e0       	ldi	r24, 0x02	; 2
     436:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     438:	83 e0       	ldi	r24, 0x03	; 3
     43a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     43c:	84 e0       	ldi	r24, 0x04	; 4
     43e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     440:	85 e0       	ldi	r24, 0x05	; 5
     442:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     444:	86 e0       	ldi	r24, 0x06	; 6
     446:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     448:	87 e0       	ldi	r24, 0x07	; 7
     44a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     44c:	88 e0       	ldi	r24, 0x08	; 8
     44e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     450:	89 e0       	ldi	r24, 0x09	; 9
     452:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     454:	80 e1       	ldi	r24, 0x10	; 16
     456:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     458:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     45a:	82 e1       	ldi	r24, 0x12	; 18
     45c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     45e:	83 e1       	ldi	r24, 0x13	; 19
     460:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     462:	84 e1       	ldi	r24, 0x14	; 20
     464:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     466:	85 e1       	ldi	r24, 0x15	; 21
     468:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     46a:	86 e1       	ldi	r24, 0x16	; 22
     46c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     46e:	87 e1       	ldi	r24, 0x17	; 23
     470:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     472:	88 e1       	ldi	r24, 0x18	; 24
     474:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     476:	89 e1       	ldi	r24, 0x19	; 25
     478:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     47a:	80 e2       	ldi	r24, 0x20	; 32
     47c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     47e:	81 e2       	ldi	r24, 0x21	; 33
     480:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     482:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     484:	83 e2       	ldi	r24, 0x23	; 35
     486:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned portSHORT ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     488:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     48a:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     48c:	86 e2       	ldi	r24, 0x26	; 38
     48e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     490:	87 e2       	ldi	r24, 0x27	; 39
     492:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     494:	88 e2       	ldi	r24, 0x28	; 40
     496:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     498:	89 e2       	ldi	r24, 0x29	; 41
     49a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     49c:	80 e3       	ldi	r24, 0x30	; 48
     49e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     4a0:	81 e3       	ldi	r24, 0x31	; 49
     4a2:	82 93       	st	-Z, r24
     4a4:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     4a6:	cf 01       	movw	r24, r30
     4a8:	08 95       	ret

000004aa <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	OCR1AH = ucHighByte;
     4aa:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     4ae:	89 ef       	ldi	r24, 0xF9	; 249
     4b0:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     4b4:	8b e0       	ldi	r24, 0x0B	; 11
     4b6:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     4ba:	ef e6       	ldi	r30, 0x6F	; 111
     4bc:	f0 e0       	ldi	r31, 0x00	; 0
     4be:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     4c0:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     4c2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4c4:	a0 91 c8 03 	lds	r26, 0x03C8
     4c8:	b0 91 c9 03 	lds	r27, 0x03C9
     4cc:	cd 91       	ld	r28, X+
     4ce:	cd bf       	out	0x3d, r28	; 61
     4d0:	dd 91       	ld	r29, X+
     4d2:	de bf       	out	0x3e, r29	; 62
     4d4:	ff 91       	pop	r31
     4d6:	ef 91       	pop	r30
     4d8:	df 91       	pop	r29
     4da:	cf 91       	pop	r28
     4dc:	bf 91       	pop	r27
     4de:	af 91       	pop	r26
     4e0:	9f 91       	pop	r25
     4e2:	8f 91       	pop	r24
     4e4:	7f 91       	pop	r23
     4e6:	6f 91       	pop	r22
     4e8:	5f 91       	pop	r21
     4ea:	4f 91       	pop	r20
     4ec:	3f 91       	pop	r19
     4ee:	2f 91       	pop	r18
     4f0:	1f 91       	pop	r17
     4f2:	0f 91       	pop	r16
     4f4:	ff 90       	pop	r15
     4f6:	ef 90       	pop	r14
     4f8:	df 90       	pop	r13
     4fa:	cf 90       	pop	r12
     4fc:	bf 90       	pop	r11
     4fe:	af 90       	pop	r10
     500:	9f 90       	pop	r9
     502:	8f 90       	pop	r8
     504:	7f 90       	pop	r7
     506:	6f 90       	pop	r6
     508:	5f 90       	pop	r5
     50a:	4f 90       	pop	r4
     50c:	3f 90       	pop	r3
     50e:	2f 90       	pop	r2
     510:	1f 90       	pop	r1
     512:	0f 90       	pop	r0
     514:	0f be       	out	0x3f, r0	; 63
     516:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     518:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     51a:	81 e0       	ldi	r24, 0x01	; 1
     51c:	08 95       	ret

0000051e <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     51e:	08 95       	ret

00000520 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     520:	0f 92       	push	r0
     522:	0f b6       	in	r0, 0x3f	; 63
     524:	f8 94       	cli
     526:	0f 92       	push	r0
     528:	1f 92       	push	r1
     52a:	11 24       	eor	r1, r1
     52c:	2f 92       	push	r2
     52e:	3f 92       	push	r3
     530:	4f 92       	push	r4
     532:	5f 92       	push	r5
     534:	6f 92       	push	r6
     536:	7f 92       	push	r7
     538:	8f 92       	push	r8
     53a:	9f 92       	push	r9
     53c:	af 92       	push	r10
     53e:	bf 92       	push	r11
     540:	cf 92       	push	r12
     542:	df 92       	push	r13
     544:	ef 92       	push	r14
     546:	ff 92       	push	r15
     548:	0f 93       	push	r16
     54a:	1f 93       	push	r17
     54c:	2f 93       	push	r18
     54e:	3f 93       	push	r19
     550:	4f 93       	push	r20
     552:	5f 93       	push	r21
     554:	6f 93       	push	r22
     556:	7f 93       	push	r23
     558:	8f 93       	push	r24
     55a:	9f 93       	push	r25
     55c:	af 93       	push	r26
     55e:	bf 93       	push	r27
     560:	cf 93       	push	r28
     562:	df 93       	push	r29
     564:	ef 93       	push	r30
     566:	ff 93       	push	r31
     568:	a0 91 c8 03 	lds	r26, 0x03C8
     56c:	b0 91 c9 03 	lds	r27, 0x03C9
     570:	0d b6       	in	r0, 0x3d	; 61
     572:	0d 92       	st	X+, r0
     574:	0e b6       	in	r0, 0x3e	; 62
     576:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     578:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <vTaskIncrementTick>
	vTaskSwitchContext();
     57c:	0e 94 88 06 	call	0xd10	; 0xd10 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     580:	a0 91 c8 03 	lds	r26, 0x03C8
     584:	b0 91 c9 03 	lds	r27, 0x03C9
     588:	cd 91       	ld	r28, X+
     58a:	cd bf       	out	0x3d, r28	; 61
     58c:	dd 91       	ld	r29, X+
     58e:	de bf       	out	0x3e, r29	; 62
     590:	ff 91       	pop	r31
     592:	ef 91       	pop	r30
     594:	df 91       	pop	r29
     596:	cf 91       	pop	r28
     598:	bf 91       	pop	r27
     59a:	af 91       	pop	r26
     59c:	9f 91       	pop	r25
     59e:	8f 91       	pop	r24
     5a0:	7f 91       	pop	r23
     5a2:	6f 91       	pop	r22
     5a4:	5f 91       	pop	r21
     5a6:	4f 91       	pop	r20
     5a8:	3f 91       	pop	r19
     5aa:	2f 91       	pop	r18
     5ac:	1f 91       	pop	r17
     5ae:	0f 91       	pop	r16
     5b0:	ff 90       	pop	r15
     5b2:	ef 90       	pop	r14
     5b4:	df 90       	pop	r13
     5b6:	cf 90       	pop	r12
     5b8:	bf 90       	pop	r11
     5ba:	af 90       	pop	r10
     5bc:	9f 90       	pop	r9
     5be:	8f 90       	pop	r8
     5c0:	7f 90       	pop	r7
     5c2:	6f 90       	pop	r6
     5c4:	5f 90       	pop	r5
     5c6:	4f 90       	pop	r4
     5c8:	3f 90       	pop	r3
     5ca:	2f 90       	pop	r2
     5cc:	1f 90       	pop	r1
     5ce:	0f 90       	pop	r0
     5d0:	0f be       	out	0x3f, r0	; 63
     5d2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5d4:	08 95       	ret

000005d6 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     5d6:	0e 94 90 02 	call	0x520	; 0x520 <vPortYieldFromTick>
		asm volatile ( "reti" );
     5da:	18 95       	reti

000005dc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5dc:	0f 92       	push	r0
     5de:	0f b6       	in	r0, 0x3f	; 63
     5e0:	f8 94       	cli
     5e2:	0f 92       	push	r0
     5e4:	1f 92       	push	r1
     5e6:	11 24       	eor	r1, r1
     5e8:	2f 92       	push	r2
     5ea:	3f 92       	push	r3
     5ec:	4f 92       	push	r4
     5ee:	5f 92       	push	r5
     5f0:	6f 92       	push	r6
     5f2:	7f 92       	push	r7
     5f4:	8f 92       	push	r8
     5f6:	9f 92       	push	r9
     5f8:	af 92       	push	r10
     5fa:	bf 92       	push	r11
     5fc:	cf 92       	push	r12
     5fe:	df 92       	push	r13
     600:	ef 92       	push	r14
     602:	ff 92       	push	r15
     604:	0f 93       	push	r16
     606:	1f 93       	push	r17
     608:	2f 93       	push	r18
     60a:	3f 93       	push	r19
     60c:	4f 93       	push	r20
     60e:	5f 93       	push	r21
     610:	6f 93       	push	r22
     612:	7f 93       	push	r23
     614:	8f 93       	push	r24
     616:	9f 93       	push	r25
     618:	af 93       	push	r26
     61a:	bf 93       	push	r27
     61c:	cf 93       	push	r28
     61e:	df 93       	push	r29
     620:	ef 93       	push	r30
     622:	ff 93       	push	r31
     624:	a0 91 c8 03 	lds	r26, 0x03C8
     628:	b0 91 c9 03 	lds	r27, 0x03C9
     62c:	0d b6       	in	r0, 0x3d	; 61
     62e:	0d 92       	st	X+, r0
     630:	0e b6       	in	r0, 0x3e	; 62
     632:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     634:	0e 94 88 06 	call	0xd10	; 0xd10 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     638:	a0 91 c8 03 	lds	r26, 0x03C8
     63c:	b0 91 c9 03 	lds	r27, 0x03C9
     640:	cd 91       	ld	r28, X+
     642:	cd bf       	out	0x3d, r28	; 61
     644:	dd 91       	ld	r29, X+
     646:	de bf       	out	0x3e, r29	; 62
     648:	ff 91       	pop	r31
     64a:	ef 91       	pop	r30
     64c:	df 91       	pop	r29
     64e:	cf 91       	pop	r28
     650:	bf 91       	pop	r27
     652:	af 91       	pop	r26
     654:	9f 91       	pop	r25
     656:	8f 91       	pop	r24
     658:	7f 91       	pop	r23
     65a:	6f 91       	pop	r22
     65c:	5f 91       	pop	r21
     65e:	4f 91       	pop	r20
     660:	3f 91       	pop	r19
     662:	2f 91       	pop	r18
     664:	1f 91       	pop	r17
     666:	0f 91       	pop	r16
     668:	ff 90       	pop	r15
     66a:	ef 90       	pop	r14
     66c:	df 90       	pop	r13
     66e:	cf 90       	pop	r12
     670:	bf 90       	pop	r11
     672:	af 90       	pop	r10
     674:	9f 90       	pop	r9
     676:	8f 90       	pop	r8
     678:	7f 90       	pop	r7
     67a:	6f 90       	pop	r6
     67c:	5f 90       	pop	r5
     67e:	4f 90       	pop	r4
     680:	3f 90       	pop	r3
     682:	2f 90       	pop	r2
     684:	1f 90       	pop	r1
     686:	0f 90       	pop	r0
     688:	0f be       	out	0x3f, r0	; 63
     68a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     68c:	08 95       	ret

0000068e <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
     68e:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
     690:	0f b6       	in	r0, 0x3f	; 63
     692:	f8 94       	cli
     694:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
     696:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     698:	0f 90       	pop	r0
     69a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     69c:	08 95       	ret

0000069e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
     69e:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
     6a0:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
     6a2:	08 95       	ret

000006a4 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
     6a4:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     6a6:	82 8d       	ldd	r24, Z+26	; 0x1a
     6a8:	90 e0       	ldi	r25, 0x00	; 0
     6aa:	88 23       	and	r24, r24
     6ac:	09 f4       	brne	.+2      	; 0x6b0 <xQueueIsQueueEmptyFromISR+0xc>
     6ae:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
     6b0:	89 2f       	mov	r24, r25
     6b2:	08 95       	ret

000006b4 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
     6b4:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     6b6:	92 8d       	ldd	r25, Z+26	; 0x1a
     6b8:	20 e0       	ldi	r18, 0x00	; 0
     6ba:	83 8d       	ldd	r24, Z+27	; 0x1b
     6bc:	98 17       	cp	r25, r24
     6be:	09 f4       	brne	.+2      	; 0x6c2 <xQueueIsQueueFullFromISR+0xe>
     6c0:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
     6c2:	82 2f       	mov	r24, r18
     6c4:	08 95       	ret

000006c6 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
     6c6:	0f 93       	push	r16
     6c8:	1f 93       	push	r17
     6ca:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
     6cc:	fc 01       	movw	r30, r24
     6ce:	80 81       	ld	r24, Z
     6d0:	91 81       	ldd	r25, Z+1	; 0x01
     6d2:	0e 94 53 00 	call	0xa6	; 0xa6 <vPortFree>
	vPortFree( pxQueue );
     6d6:	c8 01       	movw	r24, r16
     6d8:	0e 94 53 00 	call	0xa6	; 0xa6 <vPortFree>
}
     6dc:	1f 91       	pop	r17
     6de:	0f 91       	pop	r16
     6e0:	08 95       	ret

000006e2 <xQueueReceiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     6e2:	0f 93       	push	r16
     6e4:	1f 93       	push	r17
     6e6:	cf 93       	push	r28
     6e8:	df 93       	push	r29
     6ea:	ec 01       	movw	r28, r24
     6ec:	fb 01       	movw	r30, r22
     6ee:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     6f0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     6f2:	88 23       	and	r24, r24
     6f4:	81 f1       	breq	.+96     	; 0x756 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     6f6:	48 81       	ld	r20, Y
     6f8:	59 81       	ldd	r21, Y+1	; 0x01
     6fa:	41 15       	cp	r20, r1
     6fc:	51 05       	cpc	r21, r1
     6fe:	a9 f0       	breq	.+42     	; 0x72a <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     700:	8c 8d       	ldd	r24, Y+28	; 0x1c
     702:	2e 81       	ldd	r18, Y+6	; 0x06
     704:	3f 81       	ldd	r19, Y+7	; 0x07
     706:	28 0f       	add	r18, r24
     708:	31 1d       	adc	r19, r1
     70a:	3f 83       	std	Y+7, r19	; 0x07
     70c:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     70e:	8a 81       	ldd	r24, Y+2	; 0x02
     710:	9b 81       	ldd	r25, Y+3	; 0x03
     712:	28 17       	cp	r18, r24
     714:	39 07       	cpc	r19, r25
     716:	10 f0       	brcs	.+4      	; 0x71c <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     718:	5f 83       	std	Y+7, r21	; 0x07
     71a:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     71c:	4c 8d       	ldd	r20, Y+28	; 0x1c
     71e:	6e 81       	ldd	r22, Y+6	; 0x06
     720:	7f 81       	ldd	r23, Y+7	; 0x07
     722:	cf 01       	movw	r24, r30
     724:	50 e0       	ldi	r21, 0x00	; 0
     726:	0e 94 ae 0b 	call	0x175c	; 0x175c <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
     72a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     72c:	81 50       	subi	r24, 0x01	; 1
     72e:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     730:	8d 8d       	ldd	r24, Y+29	; 0x1d
     732:	8f 3f       	cpi	r24, 0xFF	; 255
     734:	69 f4       	brne	.+26     	; 0x750 <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     736:	88 85       	ldd	r24, Y+8	; 0x08
     738:	88 23       	and	r24, r24
     73a:	61 f0       	breq	.+24     	; 0x754 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     73c:	ce 01       	movw	r24, r28
     73e:	08 96       	adiw	r24, 0x08	; 8
     740:	0e 94 17 07 	call	0xe2e	; 0xe2e <xTaskRemoveFromEventList>
     744:	88 23       	and	r24, r24
     746:	31 f0       	breq	.+12     	; 0x754 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	f8 01       	movw	r30, r16
     74c:	80 83       	st	Z, r24
     74e:	03 c0       	rjmp	.+6      	; 0x756 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
     750:	8f 5f       	subi	r24, 0xFF	; 255
     752:	8d 8f       	std	Y+29, r24	; 0x1d
     754:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     756:	df 91       	pop	r29
     758:	cf 91       	pop	r28
     75a:	1f 91       	pop	r17
     75c:	0f 91       	pop	r16
     75e:	08 95       	ret

00000760 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     760:	cf 93       	push	r28
     762:	df 93       	push	r29
     764:	ec 01       	movw	r28, r24
     766:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     768:	4c 8d       	ldd	r20, Y+28	; 0x1c
     76a:	44 23       	and	r20, r20
     76c:	a1 f1       	breq	.+104    	; 0x7d6 <prvCopyDataToQueue+0x76>
                pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     76e:	88 23       	and	r24, r24
     770:	b1 f4       	brne	.+44     	; 0x79e <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     772:	8c 81       	ldd	r24, Y+4	; 0x04
     774:	9d 81       	ldd	r25, Y+5	; 0x05
     776:	50 e0       	ldi	r21, 0x00	; 0
     778:	0e 94 ae 0b 	call	0x175c	; 0x175c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     77c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     77e:	2c 81       	ldd	r18, Y+4	; 0x04
     780:	3d 81       	ldd	r19, Y+5	; 0x05
     782:	28 0f       	add	r18, r24
     784:	31 1d       	adc	r19, r1
     786:	3d 83       	std	Y+5, r19	; 0x05
     788:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     78a:	8a 81       	ldd	r24, Y+2	; 0x02
     78c:	9b 81       	ldd	r25, Y+3	; 0x03
     78e:	28 17       	cp	r18, r24
     790:	39 07       	cpc	r19, r25
     792:	08 f1       	brcs	.+66     	; 0x7d6 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     794:	88 81       	ld	r24, Y
     796:	99 81       	ldd	r25, Y+1	; 0x01
     798:	9d 83       	std	Y+5, r25	; 0x05
     79a:	8c 83       	std	Y+4, r24	; 0x04
     79c:	1c c0       	rjmp	.+56     	; 0x7d6 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     79e:	8e 81       	ldd	r24, Y+6	; 0x06
     7a0:	9f 81       	ldd	r25, Y+7	; 0x07
     7a2:	50 e0       	ldi	r21, 0x00	; 0
     7a4:	0e 94 ae 0b 	call	0x175c	; 0x175c <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     7a8:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	44 27       	eor	r20, r20
     7ae:	55 27       	eor	r21, r21
     7b0:	48 1b       	sub	r20, r24
     7b2:	59 0b       	sbc	r21, r25
     7b4:	8e 81       	ldd	r24, Y+6	; 0x06
     7b6:	9f 81       	ldd	r25, Y+7	; 0x07
     7b8:	84 0f       	add	r24, r20
     7ba:	95 1f       	adc	r25, r21
     7bc:	9f 83       	std	Y+7, r25	; 0x07
     7be:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     7c0:	28 81       	ld	r18, Y
     7c2:	39 81       	ldd	r19, Y+1	; 0x01
     7c4:	82 17       	cp	r24, r18
     7c6:	93 07       	cpc	r25, r19
     7c8:	30 f4       	brcc	.+12     	; 0x7d6 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     7ca:	8a 81       	ldd	r24, Y+2	; 0x02
     7cc:	9b 81       	ldd	r25, Y+3	; 0x03
     7ce:	84 0f       	add	r24, r20
     7d0:	95 1f       	adc	r25, r21
     7d2:	9f 83       	std	Y+7, r25	; 0x07
     7d4:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     7d6:	8a 8d       	ldd	r24, Y+26	; 0x1a
     7d8:	8f 5f       	subi	r24, 0xFF	; 255
     7da:	8a 8f       	std	Y+26, r24	; 0x1a
}
     7dc:	df 91       	pop	r29
     7de:	cf 91       	pop	r28
     7e0:	08 95       	ret

000007e2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     7e2:	0f 93       	push	r16
     7e4:	1f 93       	push	r17
     7e6:	cf 93       	push	r28
     7e8:	df 93       	push	r29
     7ea:	ec 01       	movw	r28, r24
     7ec:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     7ee:	9a 8d       	ldd	r25, Y+26	; 0x1a
     7f0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     7f2:	98 17       	cp	r25, r24
     7f4:	10 f0       	brcs	.+4      	; 0x7fa <xQueueGenericSendFromISR+0x18>
     7f6:	80 e0       	ldi	r24, 0x00	; 0
     7f8:	17 c0       	rjmp	.+46     	; 0x828 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     7fa:	ce 01       	movw	r24, r28
     7fc:	42 2f       	mov	r20, r18
     7fe:	0e 94 b0 03 	call	0x760	; 0x760 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     802:	8e 8d       	ldd	r24, Y+30	; 0x1e
     804:	8f 3f       	cpi	r24, 0xFF	; 255
     806:	69 f4       	brne	.+26     	; 0x822 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     808:	89 89       	ldd	r24, Y+17	; 0x11
     80a:	88 23       	and	r24, r24
     80c:	61 f0       	breq	.+24     	; 0x826 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     80e:	ce 01       	movw	r24, r28
     810:	41 96       	adiw	r24, 0x11	; 17
     812:	0e 94 17 07 	call	0xe2e	; 0xe2e <xTaskRemoveFromEventList>
     816:	88 23       	and	r24, r24
     818:	31 f0       	breq	.+12     	; 0x826 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	f8 01       	movw	r30, r16
     81e:	80 83       	st	Z, r24
     820:	03 c0       	rjmp	.+6      	; 0x828 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     822:	8f 5f       	subi	r24, 0xFF	; 255
     824:	8e 8f       	std	Y+30, r24	; 0x1e
     826:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     828:	df 91       	pop	r29
     82a:	cf 91       	pop	r28
     82c:	1f 91       	pop	r17
     82e:	0f 91       	pop	r16
     830:	08 95       	ret

00000832 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     832:	0f 93       	push	r16
     834:	1f 93       	push	r17
     836:	cf 93       	push	r28
     838:	df 93       	push	r29
     83a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     83c:	0f b6       	in	r0, 0x3f	; 63
     83e:	f8 94       	cli
     840:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     842:	8c 01       	movw	r16, r24
     844:	0f 5e       	subi	r16, 0xEF	; 239
     846:	1f 4f       	sbci	r17, 0xFF	; 255
     848:	0d c0       	rjmp	.+26     	; 0x864 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     84a:	89 89       	ldd	r24, Y+17	; 0x11
     84c:	88 23       	and	r24, r24
     84e:	69 f0       	breq	.+26     	; 0x86a <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     850:	c8 01       	movw	r24, r16
     852:	0e 94 17 07 	call	0xe2e	; 0xe2e <xTaskRemoveFromEventList>
     856:	88 23       	and	r24, r24
     858:	11 f0       	breq	.+4      	; 0x85e <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     85a:	0e 94 13 07 	call	0xe26	; 0xe26 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     85e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     860:	81 50       	subi	r24, 0x01	; 1
     862:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     864:	8e 8d       	ldd	r24, Y+30	; 0x1e
     866:	18 16       	cp	r1, r24
     868:	84 f3       	brlt	.-32     	; 0x84a <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     86a:	8f ef       	ldi	r24, 0xFF	; 255
     86c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     86e:	0f 90       	pop	r0
     870:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     872:	0f b6       	in	r0, 0x3f	; 63
     874:	f8 94       	cli
     876:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     878:	8e 01       	movw	r16, r28
     87a:	08 5f       	subi	r16, 0xF8	; 248
     87c:	1f 4f       	sbci	r17, 0xFF	; 255
     87e:	0d c0       	rjmp	.+26     	; 0x89a <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     880:	88 85       	ldd	r24, Y+8	; 0x08
     882:	88 23       	and	r24, r24
     884:	69 f0       	breq	.+26     	; 0x8a0 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     886:	c8 01       	movw	r24, r16
     888:	0e 94 17 07 	call	0xe2e	; 0xe2e <xTaskRemoveFromEventList>
     88c:	88 23       	and	r24, r24
     88e:	11 f0       	breq	.+4      	; 0x894 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
     890:	0e 94 13 07 	call	0xe26	; 0xe26 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     894:	8d 8d       	ldd	r24, Y+29	; 0x1d
     896:	81 50       	subi	r24, 0x01	; 1
     898:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     89a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     89c:	18 16       	cp	r1, r24
     89e:	84 f3       	brlt	.-32     	; 0x880 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     8a0:	8f ef       	ldi	r24, 0xFF	; 255
     8a2:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     8a4:	0f 90       	pop	r0
     8a6:	0f be       	out	0x3f, r0	; 63
}
     8a8:	df 91       	pop	r29
     8aa:	cf 91       	pop	r28
     8ac:	1f 91       	pop	r17
     8ae:	0f 91       	pop	r16
     8b0:	08 95       	ret

000008b2 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     8b2:	3f 92       	push	r3
     8b4:	4f 92       	push	r4
     8b6:	5f 92       	push	r5
     8b8:	6f 92       	push	r6
     8ba:	7f 92       	push	r7
     8bc:	8f 92       	push	r8
     8be:	9f 92       	push	r9
     8c0:	af 92       	push	r10
     8c2:	bf 92       	push	r11
     8c4:	cf 92       	push	r12
     8c6:	df 92       	push	r13
     8c8:	ef 92       	push	r14
     8ca:	ff 92       	push	r15
     8cc:	0f 93       	push	r16
     8ce:	1f 93       	push	r17
     8d0:	df 93       	push	r29
     8d2:	cf 93       	push	r28
     8d4:	00 d0       	rcall	.+0      	; 0x8d6 <xQueueGenericReceive+0x24>
     8d6:	00 d0       	rcall	.+0      	; 0x8d8 <xQueueGenericReceive+0x26>
     8d8:	00 d0       	rcall	.+0      	; 0x8da <xQueueGenericReceive+0x28>
     8da:	cd b7       	in	r28, 0x3d	; 61
     8dc:	de b7       	in	r29, 0x3e	; 62
     8de:	8c 01       	movw	r16, r24
     8e0:	36 2e       	mov	r3, r22
     8e2:	47 2e       	mov	r4, r23
     8e4:	5d 83       	std	Y+5, r21	; 0x05
     8e6:	4c 83       	std	Y+4, r20	; 0x04
     8e8:	52 2e       	mov	r5, r18
							portEXIT_CRITICAL();
						}
					}
					#endif

					vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     8ea:	21 e1       	ldi	r18, 0x11	; 17
     8ec:	a2 2e       	mov	r10, r18
     8ee:	b1 2c       	mov	r11, r1
     8f0:	a8 0e       	add	r10, r24
     8f2:	b9 1e       	adc	r11, r25
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     8f4:	98 e0       	ldi	r25, 0x08	; 8
     8f6:	89 2e       	mov	r8, r25
     8f8:	91 2c       	mov	r9, r1
     8fa:	80 0e       	add	r8, r16
     8fc:	91 1e       	adc	r9, r17
     8fe:	81 e0       	ldi	r24, 0x01	; 1
     900:	8e 83       	std	Y+6, r24	; 0x06
			if( prvIsQueueEmpty( pxQueue ) )
			{
	    		/* Need to call xTaskCheckForTimeout again as time could
	    		have passed since it was last called if this is not the
	    		first time around this loop. */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     902:	84 e0       	ldi	r24, 0x04	; 4
     904:	68 2e       	mov	r6, r24
     906:	71 2c       	mov	r7, r1
     908:	6c 0e       	add	r6, r28
     90a:	7d 1e       	adc	r7, r29
     90c:	6e 01       	movw	r12, r28
     90e:	08 94       	sec
     910:	c1 1c       	adc	r12, r1
     912:	d1 1c       	adc	r13, r1
signed portCHAR *pcOriginalReadPosition;

	do
	{
		/* If there are no messages in the queue we may have to block. */
		if( xTicksToWait > ( portTickType ) 0 )
     914:	8c 81       	ldd	r24, Y+4	; 0x04
     916:	9d 81       	ldd	r25, Y+5	; 0x05
     918:	89 2b       	or	r24, r25
     91a:	09 f4       	brne	.+2      	; 0x91e <xQueueGenericReceive+0x6c>
     91c:	3a c0       	rjmp	.+116    	; 0x992 <xQueueGenericReceive+0xe0>
		{
			vTaskSuspendAll();
     91e:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <vTaskSuspendAll>
			prvLockQueue( pxQueue );
     922:	0f b6       	in	r0, 0x3f	; 63
     924:	f8 94       	cli
     926:	0f 92       	push	r0
     928:	f8 01       	movw	r30, r16
     92a:	85 8d       	ldd	r24, Z+29	; 0x1d
     92c:	8f 3f       	cpi	r24, 0xFF	; 255
     92e:	09 f4       	brne	.+2      	; 0x932 <xQueueGenericReceive+0x80>
     930:	15 8e       	std	Z+29, r1	; 0x1d
     932:	f8 01       	movw	r30, r16
     934:	86 8d       	ldd	r24, Z+30	; 0x1e
     936:	8f 3f       	cpi	r24, 0xFF	; 255
     938:	09 f4       	brne	.+2      	; 0x93c <xQueueGenericReceive+0x8a>
     93a:	16 8e       	std	Z+30, r1	; 0x1e
     93c:	0f 90       	pop	r0
     93e:	0f be       	out	0x3f, r0	; 63

			if( xReturn == pdTRUE )
     940:	fe 81       	ldd	r31, Y+6	; 0x06
     942:	f1 30       	cpi	r31, 0x01	; 1
     944:	19 f4       	brne	.+6      	; 0x94c <xQueueGenericReceive+0x9a>
			{
				/* This is the first time through - we need to capture the
				time while the scheduler is locked to ensure we attempt to
				block at least once. */
				vTaskSetTimeOutState( &xTimeOut );
     946:	c6 01       	movw	r24, r12
     948:	0e 94 ca 06 	call	0xd94	; 0xd94 <vTaskSetTimeOutState>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     94c:	0f b6       	in	r0, 0x3f	; 63
     94e:	f8 94       	cli
     950:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     952:	f8 01       	movw	r30, r16
     954:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     956:	0f 90       	pop	r0
     958:	0f be       	out	0x3f, r0	; 63
				time while the scheduler is locked to ensure we attempt to
				block at least once. */
				vTaskSetTimeOutState( &xTimeOut );
			}

			if( prvIsQueueEmpty( pxQueue ) )
     95a:	88 23       	and	r24, r24
     95c:	a9 f4       	brne	.+42     	; 0x988 <xQueueGenericReceive+0xd6>
			{
	    		/* Need to call xTaskCheckForTimeout again as time could
	    		have passed since it was last called if this is not the
	    		first time around this loop. */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     95e:	c6 01       	movw	r24, r12
     960:	b3 01       	movw	r22, r6
     962:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskCheckForTimeOut>
     966:	88 23       	and	r24, r24
     968:	79 f4       	brne	.+30     	; 0x988 <xQueueGenericReceive+0xd6>
							portEXIT_CRITICAL();
						}
					}
					#endif

					vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     96a:	6c 81       	ldd	r22, Y+4	; 0x04
     96c:	7d 81       	ldd	r23, Y+5	; 0x05
     96e:	c5 01       	movw	r24, r10
     970:	0e 94 1e 08 	call	0x103c	; 0x103c <vTaskPlaceOnEventList>
					prvUnlockQueue( pxQueue );
     974:	c8 01       	movw	r24, r16
     976:	0e 94 19 04 	call	0x832	; 0x832 <prvUnlockQueue>
					if( !xTaskResumeAll() )
     97a:	0e 94 66 08 	call	0x10cc	; 0x10cc <xTaskResumeAll>
     97e:	88 23       	and	r24, r24
     980:	41 f4       	brne	.+16     	; 0x992 <xQueueGenericReceive+0xe0>
					{
						taskYIELD();
     982:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
     986:	05 c0       	rjmp	.+10     	; 0x992 <xQueueGenericReceive+0xe0>
					( void ) xTaskResumeAll();
				}
			}
			else
			{
				prvUnlockQueue( pxQueue );
     988:	c8 01       	movw	r24, r16
     98a:	0e 94 19 04 	call	0x832	; 0x832 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     98e:	0e 94 66 08 	call	0x10cc	; 0x10cc <xTaskResumeAll>
		}

/* The two tasks are blocked on the queue, the low priority task is polling/running. */

/* An interrupt occurs here - which unblocks the HP tasks, but they do not run. */
		taskENTER_CRITICAL();
     992:	0f b6       	in	r0, 0x3f	; 63
     994:	f8 94       	cli
     996:	0f 92       	push	r0
		{
/* Because the interrupt occurred the LP task manages to grab the data as the other two tasks are not yet running. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     998:	f8 01       	movw	r30, r16
     99a:	82 8d       	ldd	r24, Z+26	; 0x1a
     99c:	88 23       	and	r24, r24
     99e:	11 f4       	brne	.+4      	; 0x9a4 <xQueueGenericReceive+0xf2>
     9a0:	ff 24       	eor	r15, r15
     9a2:	3c c0       	rjmp	.+120    	; 0xa1c <xQueueGenericReceive+0x16a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     9a4:	f8 01       	movw	r30, r16
     9a6:	e6 80       	ldd	r14, Z+6	; 0x06
     9a8:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     9aa:	40 81       	ld	r20, Z
     9ac:	51 81       	ldd	r21, Z+1	; 0x01
     9ae:	41 15       	cp	r20, r1
     9b0:	51 05       	cpc	r21, r1
     9b2:	b1 f0       	breq	.+44     	; 0x9e0 <xQueueGenericReceive+0x12e>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     9b4:	84 8d       	ldd	r24, Z+28	; 0x1c
     9b6:	97 01       	movw	r18, r14
     9b8:	28 0f       	add	r18, r24
     9ba:	31 1d       	adc	r19, r1
     9bc:	37 83       	std	Z+7, r19	; 0x07
     9be:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     9c0:	82 81       	ldd	r24, Z+2	; 0x02
     9c2:	93 81       	ldd	r25, Z+3	; 0x03
     9c4:	28 17       	cp	r18, r24
     9c6:	39 07       	cpc	r19, r25
     9c8:	10 f0       	brcs	.+4      	; 0x9ce <xQueueGenericReceive+0x11c>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     9ca:	57 83       	std	Z+7, r21	; 0x07
     9cc:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     9ce:	f8 01       	movw	r30, r16
     9d0:	44 8d       	ldd	r20, Z+28	; 0x1c
     9d2:	66 81       	ldd	r22, Z+6	; 0x06
     9d4:	77 81       	ldd	r23, Z+7	; 0x07
     9d6:	83 2d       	mov	r24, r3
     9d8:	94 2d       	mov	r25, r4
     9da:	50 e0       	ldi	r21, 0x00	; 0
     9dc:	0e 94 ae 0b 	call	0x175c	; 0x175c <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
     9e0:	55 20       	and	r5, r5
     9e2:	69 f4       	brne	.+26     	; 0x9fe <xQueueGenericReceive+0x14c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     9e4:	f8 01       	movw	r30, r16
     9e6:	82 8d       	ldd	r24, Z+26	; 0x1a
     9e8:	81 50       	subi	r24, 0x01	; 1
     9ea:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     9ec:	80 85       	ldd	r24, Z+8	; 0x08
     9ee:	88 23       	and	r24, r24
     9f0:	99 f0       	breq	.+38     	; 0xa18 <xQueueGenericReceive+0x166>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     9f2:	c4 01       	movw	r24, r8
     9f4:	0e 94 17 07 	call	0xe2e	; 0xe2e <xTaskRemoveFromEventList>
     9f8:	81 30       	cpi	r24, 0x01	; 1
     9fa:	71 f4       	brne	.+28     	; 0xa18 <xQueueGenericReceive+0x166>
     9fc:	0b c0       	rjmp	.+22     	; 0xa14 <xQueueGenericReceive+0x162>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     9fe:	f8 01       	movw	r30, r16
     a00:	f7 82       	std	Z+7, r15	; 0x07
     a02:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     a04:	81 89       	ldd	r24, Z+17	; 0x11
     a06:	88 23       	and	r24, r24
     a08:	39 f0       	breq	.+14     	; 0xa18 <xQueueGenericReceive+0x166>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a0a:	c5 01       	movw	r24, r10
     a0c:	0e 94 17 07 	call	0xe2e	; 0xe2e <xTaskRemoveFromEventList>
     a10:	88 23       	and	r24, r24
     a12:	11 f0       	breq	.+4      	; 0xa18 <xQueueGenericReceive+0x166>
						{
							/* The task waiting has a higher priority than this task. */
							taskYIELD();
     a14:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
     a18:	ff 24       	eor	r15, r15
     a1a:	f3 94       	inc	r15
			else
			{
				xReturn = errQUEUE_EMPTY;
			}
		}
		taskEXIT_CRITICAL();
     a1c:	0f 90       	pop	r0
     a1e:	0f be       	out	0x3f, r0	; 63

		if( xReturn == errQUEUE_EMPTY )
     a20:	ff 20       	and	r15, r15
     a22:	19 f0       	breq	.+6      	; 0xa2a <xQueueGenericReceive+0x178>
     a24:	ff 24       	eor	r15, r15
     a26:	f3 94       	inc	r15
     a28:	0d c0       	rjmp	.+26     	; 0xa44 <xQueueGenericReceive+0x192>
		{
			if( xTicksToWait > ( portTickType ) 0 )
     a2a:	8c 81       	ldd	r24, Y+4	; 0x04
     a2c:	9d 81       	ldd	r25, Y+5	; 0x05
     a2e:	89 2b       	or	r24, r25
     a30:	49 f0       	breq	.+18     	; 0xa44 <xQueueGenericReceive+0x192>
			{
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     a32:	c6 01       	movw	r24, r12
     a34:	b3 01       	movw	r22, r6
     a36:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskCheckForTimeOut>
     a3a:	ff ef       	ldi	r31, 0xFF	; 255
     a3c:	fe 83       	std	Y+6, r31	; 0x06
     a3e:	88 23       	and	r24, r24
     a40:	09 f4       	brne	.+2      	; 0xa44 <xQueueGenericReceive+0x192>
     a42:	68 cf       	rjmp	.-304    	; 0x914 <xQueueGenericReceive+0x62>
		}

	} while( xReturn == queueERRONEOUS_UNBLOCK );

	return xReturn;
}
     a44:	8f 2d       	mov	r24, r15
     a46:	26 96       	adiw	r28, 0x06	; 6
     a48:	0f b6       	in	r0, 0x3f	; 63
     a4a:	f8 94       	cli
     a4c:	de bf       	out	0x3e, r29	; 62
     a4e:	0f be       	out	0x3f, r0	; 63
     a50:	cd bf       	out	0x3d, r28	; 61
     a52:	cf 91       	pop	r28
     a54:	df 91       	pop	r29
     a56:	1f 91       	pop	r17
     a58:	0f 91       	pop	r16
     a5a:	ff 90       	pop	r15
     a5c:	ef 90       	pop	r14
     a5e:	df 90       	pop	r13
     a60:	cf 90       	pop	r12
     a62:	bf 90       	pop	r11
     a64:	af 90       	pop	r10
     a66:	9f 90       	pop	r9
     a68:	8f 90       	pop	r8
     a6a:	7f 90       	pop	r7
     a6c:	6f 90       	pop	r6
     a6e:	5f 90       	pop	r5
     a70:	4f 90       	pop	r4
     a72:	3f 90       	pop	r3
     a74:	08 95       	ret

00000a76 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     a76:	4f 92       	push	r4
     a78:	5f 92       	push	r5
     a7a:	6f 92       	push	r6
     a7c:	7f 92       	push	r7
     a7e:	8f 92       	push	r8
     a80:	9f 92       	push	r9
     a82:	af 92       	push	r10
     a84:	bf 92       	push	r11
     a86:	cf 92       	push	r12
     a88:	df 92       	push	r13
     a8a:	ef 92       	push	r14
     a8c:	ff 92       	push	r15
     a8e:	0f 93       	push	r16
     a90:	1f 93       	push	r17
     a92:	df 93       	push	r29
     a94:	cf 93       	push	r28
     a96:	00 d0       	rcall	.+0      	; 0xa98 <xQueueGenericSend+0x22>
     a98:	00 d0       	rcall	.+0      	; 0xa9a <xQueueGenericSend+0x24>
     a9a:	00 d0       	rcall	.+0      	; 0xa9c <xQueueGenericSend+0x26>
     a9c:	cd b7       	in	r28, 0x3d	; 61
     a9e:	de b7       	in	r29, 0x3e	; 62
     aa0:	8c 01       	movw	r16, r24
     aa2:	3b 01       	movw	r6, r22
     aa4:	5d 83       	std	Y+5, r21	; 0x05
     aa6:	4c 83       	std	Y+4, r20	; 0x04
     aa8:	e2 2e       	mov	r14, r18
	    		have passed since it was last called if this is not the
	    		first time around this loop.  */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
				{
					traceBLOCKING_ON_QUEUE_SEND( pxQueue );
					vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     aaa:	58 e0       	ldi	r21, 0x08	; 8
     aac:	85 2e       	mov	r8, r21
     aae:	91 2c       	mov	r9, r1
     ab0:	88 0e       	add	r8, r24
     ab2:	99 1e       	adc	r9, r25

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     ab4:	41 e1       	ldi	r20, 0x11	; 17
     ab6:	a4 2e       	mov	r10, r20
     ab8:	b1 2c       	mov	r11, r1
     aba:	a8 0e       	add	r10, r24
     abc:	b9 1e       	adc	r11, r25
     abe:	81 e0       	ldi	r24, 0x01	; 1
     ac0:	8e 83       	std	Y+6, r24	; 0x06
			if( prvIsQueueFull( pxQueue ) )
			{
	    		/* Need to call xTaskCheckForTimeout again as time could
	    		have passed since it was last called if this is not the
	    		first time around this loop.  */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ac2:	34 e0       	ldi	r19, 0x04	; 4
     ac4:	43 2e       	mov	r4, r19
     ac6:	51 2c       	mov	r5, r1
     ac8:	4c 0e       	add	r4, r28
     aca:	5d 1e       	adc	r5, r29
     acc:	6e 01       	movw	r12, r28
     ace:	08 94       	sec
     ad0:	c1 1c       	adc	r12, r1
     ad2:	d1 1c       	adc	r13, r1

	do
	{
    	/* If xTicksToWait is zero then we are not going to block even
    	if there is no room in the queue to post. */
		if( xTicksToWait > ( portTickType ) 0 )
     ad4:	8c 81       	ldd	r24, Y+4	; 0x04
     ad6:	9d 81       	ldd	r25, Y+5	; 0x05
     ad8:	89 2b       	or	r24, r25
     ada:	09 f4       	brne	.+2      	; 0xade <xQueueGenericSend+0x68>
     adc:	3c c0       	rjmp	.+120    	; 0xb56 <xQueueGenericSend+0xe0>
		{
			vTaskSuspendAll();
     ade:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <vTaskSuspendAll>
			prvLockQueue( pxQueue );
     ae2:	0f b6       	in	r0, 0x3f	; 63
     ae4:	f8 94       	cli
     ae6:	0f 92       	push	r0
     ae8:	f8 01       	movw	r30, r16
     aea:	85 8d       	ldd	r24, Z+29	; 0x1d
     aec:	8f 3f       	cpi	r24, 0xFF	; 255
     aee:	09 f4       	brne	.+2      	; 0xaf2 <xQueueGenericSend+0x7c>
     af0:	15 8e       	std	Z+29, r1	; 0x1d
     af2:	f8 01       	movw	r30, r16
     af4:	86 8d       	ldd	r24, Z+30	; 0x1e
     af6:	8f 3f       	cpi	r24, 0xFF	; 255
     af8:	09 f4       	brne	.+2      	; 0xafc <xQueueGenericSend+0x86>
     afa:	16 8e       	std	Z+30, r1	; 0x1e
     afc:	0f 90       	pop	r0
     afe:	0f be       	out	0x3f, r0	; 63

			if( xReturn == pdTRUE )
     b00:	fe 81       	ldd	r31, Y+6	; 0x06
     b02:	f1 30       	cpi	r31, 0x01	; 1
     b04:	19 f4       	brne	.+6      	; 0xb0c <xQueueGenericSend+0x96>
			{
				/* This is the first time through - we need to capture the
				time while the scheduler is locked to ensure we attempt to
				block at least once. */
				vTaskSetTimeOutState( &xTimeOut );
     b06:	c6 01       	movw	r24, r12
     b08:	0e 94 ca 06 	call	0xd94	; 0xd94 <vTaskSetTimeOutState>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     b0c:	0f b6       	in	r0, 0x3f	; 63
     b0e:	f8 94       	cli
     b10:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     b12:	f8 01       	movw	r30, r16
     b14:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     b16:	0f 90       	pop	r0
     b18:	0f be       	out	0x3f, r0	; 63
				time while the scheduler is locked to ensure we attempt to
				block at least once. */
				vTaskSetTimeOutState( &xTimeOut );
			}

			if( prvIsQueueFull( pxQueue ) )
     b1a:	f8 01       	movw	r30, r16
     b1c:	83 8d       	ldd	r24, Z+27	; 0x1b
     b1e:	98 17       	cp	r25, r24
     b20:	a9 f4       	brne	.+42     	; 0xb4c <xQueueGenericSend+0xd6>
			{
	    		/* Need to call xTaskCheckForTimeout again as time could
	    		have passed since it was last called if this is not the
	    		first time around this loop.  */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b22:	c6 01       	movw	r24, r12
     b24:	b2 01       	movw	r22, r4
     b26:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskCheckForTimeOut>
     b2a:	88 23       	and	r24, r24
     b2c:	79 f4       	brne	.+30     	; 0xb4c <xQueueGenericSend+0xd6>
				{
					traceBLOCKING_ON_QUEUE_SEND( pxQueue );
					vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     b2e:	6c 81       	ldd	r22, Y+4	; 0x04
     b30:	7d 81       	ldd	r23, Y+5	; 0x05
     b32:	c4 01       	movw	r24, r8
     b34:	0e 94 1e 08 	call	0x103c	; 0x103c <vTaskPlaceOnEventList>
					/* Unlocking the queue means queue events can effect the
					event list.  It is possible	that interrupts occurring now
					remove this task from the event	list again - but as the
					scheduler is suspended the task will go onto the pending
					ready last instead of the actual ready list. */
					prvUnlockQueue( pxQueue );
     b38:	c8 01       	movw	r24, r16
     b3a:	0e 94 19 04 	call	0x832	; 0x832 <prvUnlockQueue>
					/* Resuming the scheduler will move tasks from the pending
					ready list into the ready list - so it is feasible that this
					task is already in a ready list before it yields - in which
					case the yield will not cause a context switch unless there
					is also a higher priority task in the pending ready list. */
					if( !xTaskResumeAll() )
     b3e:	0e 94 66 08 	call	0x10cc	; 0x10cc <xTaskResumeAll>
     b42:	88 23       	and	r24, r24
     b44:	41 f4       	brne	.+16     	; 0xb56 <xQueueGenericSend+0xe0>
					{
						taskYIELD();
     b46:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
     b4a:	05 c0       	rjmp	.+10     	; 0xb56 <xQueueGenericSend+0xe0>
			}
			else
			{
    			/* The queue was not full so we can just unlock the
    			scheduler and queue again before carrying on. */
				prvUnlockQueue( pxQueue );
     b4c:	c8 01       	movw	r24, r16
     b4e:	0e 94 19 04 	call	0x832	; 0x832 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b52:	0e 94 66 08 	call	0x10cc	; 0x10cc <xTaskResumeAll>

  		/* Higher priority tasks and interrupts can execute during
  		this time and could possible refill the queue - even if we
  		unblocked because space became available. */

		taskENTER_CRITICAL();
     b56:	0f b6       	in	r0, 0x3f	; 63
     b58:	f8 94       	cli
     b5a:	0f 92       	push	r0
		{
  			/* Is there room on the queue now?  To be running we must be
  			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     b5c:	f8 01       	movw	r30, r16
     b5e:	92 8d       	ldd	r25, Z+26	; 0x1a
     b60:	83 8d       	ldd	r24, Z+27	; 0x1b
     b62:	98 17       	cp	r25, r24
     b64:	10 f0       	brcs	.+4      	; 0xb6a <xQueueGenericSend+0xf4>
     b66:	ff 24       	eor	r15, r15
     b68:	12 c0       	rjmp	.+36     	; 0xb8e <xQueueGenericSend+0x118>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     b6a:	c8 01       	movw	r24, r16
     b6c:	b3 01       	movw	r22, r6
     b6e:	4e 2d       	mov	r20, r14
     b70:	0e 94 b0 03 	call	0x760	; 0x760 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b74:	f8 01       	movw	r30, r16
     b76:	81 89       	ldd	r24, Z+17	; 0x11
     b78:	88 23       	and	r24, r24
     b7a:	39 f0       	breq	.+14     	; 0xb8a <xQueueGenericSend+0x114>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     b7c:	c5 01       	movw	r24, r10
     b7e:	0e 94 17 07 	call	0xe2e	; 0xe2e <xTaskRemoveFromEventList>
     b82:	81 30       	cpi	r24, 0x01	; 1
     b84:	11 f4       	brne	.+4      	; 0xb8a <xQueueGenericSend+0x114>
					{
					    /* The unblocked task has a priority higher than
					    our own so yield immediately. */
					    taskYIELD();
     b86:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
     b8a:	ff 24       	eor	r15, r15
     b8c:	f3 94       	inc	r15
  				task being unblocked and subsequently attempting to write
  				to the queue. */
				xReturn = errQUEUE_FULL;
			}
		}
		taskEXIT_CRITICAL();
     b8e:	0f 90       	pop	r0
     b90:	0f be       	out	0x3f, r0	; 63

		if( xReturn == errQUEUE_FULL )
     b92:	ff 20       	and	r15, r15
     b94:	19 f0       	breq	.+6      	; 0xb9c <xQueueGenericSend+0x126>
     b96:	ff 24       	eor	r15, r15
     b98:	f3 94       	inc	r15
     b9a:	0d c0       	rjmp	.+26     	; 0xbb6 <xQueueGenericSend+0x140>
		{
			if( xTicksToWait > ( portTickType ) 0 )
     b9c:	8c 81       	ldd	r24, Y+4	; 0x04
     b9e:	9d 81       	ldd	r25, Y+5	; 0x05
     ba0:	89 2b       	or	r24, r25
     ba2:	49 f0       	breq	.+18     	; 0xbb6 <xQueueGenericSend+0x140>
			{
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ba4:	c6 01       	movw	r24, r12
     ba6:	b2 01       	movw	r22, r4
     ba8:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskCheckForTimeOut>
     bac:	ff ef       	ldi	r31, 0xFF	; 255
     bae:	fe 83       	std	Y+6, r31	; 0x06
     bb0:	88 23       	and	r24, r24
     bb2:	09 f4       	brne	.+2      	; 0xbb6 <xQueueGenericSend+0x140>
     bb4:	8f cf       	rjmp	.-226    	; 0xad4 <xQueueGenericSend+0x5e>
		}
	}
	while( xReturn == queueERRONEOUS_UNBLOCK );

	return xReturn;
}
     bb6:	8f 2d       	mov	r24, r15
     bb8:	26 96       	adiw	r28, 0x06	; 6
     bba:	0f b6       	in	r0, 0x3f	; 63
     bbc:	f8 94       	cli
     bbe:	de bf       	out	0x3e, r29	; 62
     bc0:	0f be       	out	0x3f, r0	; 63
     bc2:	cd bf       	out	0x3d, r28	; 61
     bc4:	cf 91       	pop	r28
     bc6:	df 91       	pop	r29
     bc8:	1f 91       	pop	r17
     bca:	0f 91       	pop	r16
     bcc:	ff 90       	pop	r15
     bce:	ef 90       	pop	r14
     bd0:	df 90       	pop	r13
     bd2:	cf 90       	pop	r12
     bd4:	bf 90       	pop	r11
     bd6:	af 90       	pop	r10
     bd8:	9f 90       	pop	r9
     bda:	8f 90       	pop	r8
     bdc:	7f 90       	pop	r7
     bde:	6f 90       	pop	r6
     be0:	5f 90       	pop	r5
     be2:	4f 90       	pop	r4
     be4:	08 95       	ret

00000be6 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     be6:	8f 92       	push	r8
     be8:	9f 92       	push	r9
     bea:	af 92       	push	r10
     bec:	bf 92       	push	r11
     bee:	cf 92       	push	r12
     bf0:	df 92       	push	r13
     bf2:	ef 92       	push	r14
     bf4:	ff 92       	push	r15
     bf6:	0f 93       	push	r16
     bf8:	1f 93       	push	r17
     bfa:	cf 93       	push	r28
     bfc:	df 93       	push	r29
     bfe:	98 2e       	mov	r9, r24
     c00:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     c02:	88 23       	and	r24, r24
     c04:	09 f4       	brne	.+2      	; 0xc08 <xQueueCreate+0x22>
     c06:	42 c0       	rjmp	.+132    	; 0xc8c <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     c08:	8f e1       	ldi	r24, 0x1F	; 31
     c0a:	90 e0       	ldi	r25, 0x00	; 0
     c0c:	0e 94 59 00 	call	0xb2	; 0xb2 <pvPortMalloc>
     c10:	8c 01       	movw	r16, r24
     c12:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     c14:	00 97       	sbiw	r24, 0x00	; 0
     c16:	e1 f1       	breq	.+120    	; 0xc90 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     c18:	c9 2c       	mov	r12, r9
     c1a:	dd 24       	eor	r13, r13
     c1c:	a8 2c       	mov	r10, r8
     c1e:	bb 24       	eor	r11, r11
     c20:	ac 9c       	mul	r10, r12
     c22:	70 01       	movw	r14, r0
     c24:	ad 9c       	mul	r10, r13
     c26:	f0 0c       	add	r15, r0
     c28:	bc 9c       	mul	r11, r12
     c2a:	f0 0c       	add	r15, r0
     c2c:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed portCHAR * ) pvPortMalloc( xQueueSizeInBytes );
     c2e:	c7 01       	movw	r24, r14
     c30:	01 96       	adiw	r24, 0x01	; 1
     c32:	0e 94 59 00 	call	0xb2	; 0xb2 <pvPortMalloc>
     c36:	9c 01       	movw	r18, r24
     c38:	99 83       	std	Y+1, r25	; 0x01
     c3a:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     c3c:	00 97       	sbiw	r24, 0x00	; 0
     c3e:	19 f1       	breq	.+70     	; 0xc86 <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     c40:	e8 0e       	add	r14, r24
     c42:	f9 1e       	adc	r15, r25
     c44:	fb 82       	std	Y+3, r15	; 0x03
     c46:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
     c48:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     c4a:	9d 83       	std	Y+5, r25	; 0x05
     c4c:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
     c4e:	08 94       	sec
     c50:	c1 08       	sbc	r12, r1
     c52:	d1 08       	sbc	r13, r1
     c54:	ca 9c       	mul	r12, r10
     c56:	c0 01       	movw	r24, r0
     c58:	cb 9c       	mul	r12, r11
     c5a:	90 0d       	add	r25, r0
     c5c:	da 9c       	mul	r13, r10
     c5e:	90 0d       	add	r25, r0
     c60:	11 24       	eor	r1, r1
     c62:	28 0f       	add	r18, r24
     c64:	39 1f       	adc	r19, r25
     c66:	3f 83       	std	Y+7, r19	; 0x07
     c68:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     c6a:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     c6c:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     c6e:	8f ef       	ldi	r24, 0xFF	; 255
     c70:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     c72:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     c74:	c8 01       	movw	r24, r16
     c76:	08 96       	adiw	r24, 0x08	; 8
     c78:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     c7c:	c8 01       	movw	r24, r16
     c7e:	41 96       	adiw	r24, 0x11	; 17
     c80:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>
     c84:	05 c0       	rjmp	.+10     	; 0xc90 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     c86:	c8 01       	movw	r24, r16
     c88:	0e 94 53 00 	call	0xa6	; 0xa6 <vPortFree>
     c8c:	c0 e0       	ldi	r28, 0x00	; 0
     c8e:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
     c90:	ce 01       	movw	r24, r28
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	1f 91       	pop	r17
     c98:	0f 91       	pop	r16
     c9a:	ff 90       	pop	r15
     c9c:	ef 90       	pop	r14
     c9e:	df 90       	pop	r13
     ca0:	cf 90       	pop	r12
     ca2:	bf 90       	pop	r11
     ca4:	af 90       	pop	r10
     ca6:	9f 90       	pop	r9
     ca8:	8f 90       	pop	r8
     caa:	08 95       	ret

00000cac <xTaskIsTaskSuspended>:
#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
     cac:	fc 01       	movw	r30, r24

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     cae:	82 85       	ldd	r24, Z+10	; 0x0a
     cb0:	93 85       	ldd	r25, Z+11	; 0x0b
     cb2:	81 52       	subi	r24, 0x21	; 33
     cb4:	94 40       	sbci	r25, 0x04	; 4
     cb6:	59 f4       	brne	.+22     	; 0xcce <xTaskIsTaskSuspended+0x22>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     cb8:	84 89       	ldd	r24, Z+20	; 0x14
     cba:	95 89       	ldd	r25, Z+21	; 0x15
     cbc:	24 e0       	ldi	r18, 0x04	; 4
     cbe:	8f 30       	cpi	r24, 0x0F	; 15
     cc0:	92 07       	cpc	r25, r18
     cc2:	29 f0       	breq	.+10     	; 0xcce <xTaskIsTaskSuspended+0x22>
     cc4:	20 e0       	ldi	r18, 0x00	; 0
     cc6:	89 2b       	or	r24, r25
     cc8:	19 f4       	brne	.+6      	; 0xcd0 <xTaskIsTaskSuspended+0x24>
     cca:	21 e0       	ldi	r18, 0x01	; 1
     ccc:	01 c0       	rjmp	.+2      	; 0xcd0 <xTaskIsTaskSuspended+0x24>
     cce:	20 e0       	ldi	r18, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
     cd0:	82 2f       	mov	r24, r18
     cd2:	08 95       	ret

00000cd4 <vTaskSuspendAll>:
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
	portENTER_CRITICAL();
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	0f 92       	push	r0
		++uxSchedulerSuspended;
     cda:	80 91 ce 03 	lds	r24, 0x03CE
     cde:	8f 5f       	subi	r24, 0xFF	; 255
     ce0:	80 93 ce 03 	sts	0x03CE, r24
	portEXIT_CRITICAL();
     ce4:	0f 90       	pop	r0
     ce6:	0f be       	out	0x3f, r0	; 63
}
     ce8:	08 95       	ret

00000cea <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     cf0:	20 91 cc 03 	lds	r18, 0x03CC
     cf4:	30 91 cd 03 	lds	r19, 0x03CD
	}
	taskEXIT_CRITICAL();
     cf8:	0f 90       	pop	r0
     cfa:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     cfc:	c9 01       	movw	r24, r18
     cfe:	08 95       	ret

00000d00 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
unsigned portBASE_TYPE uxNumberOfTasks;

	taskENTER_CRITICAL();
     d00:	0f b6       	in	r0, 0x3f	; 63
     d02:	f8 94       	cli
     d04:	0f 92       	push	r0
		uxNumberOfTasks = uxCurrentNumberOfTasks;
     d06:	80 91 d1 03 	lds	r24, 0x03D1
	taskEXIT_CRITICAL();
     d0a:	0f 90       	pop	r0
     d0c:	0f be       	out	0x3f, r0	; 63

	return uxNumberOfTasks;
}
     d0e:	08 95       	ret

00000d10 <vTaskSwitchContext>:

void vTaskSwitchContext( void )
{
	traceTASK_SWITCHED_OUT();

	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     d10:	80 91 ce 03 	lds	r24, 0x03CE
     d14:	88 23       	and	r24, r24
     d16:	51 f0       	breq	.+20     	; 0xd2c <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     d18:	81 e0       	ldi	r24, 0x01	; 1
     d1a:	80 93 ca 03 	sts	0x03CA, r24
     d1e:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
     d20:	80 91 cf 03 	lds	r24, 0x03CF
     d24:	81 50       	subi	r24, 0x01	; 1
     d26:	80 93 cf 03 	sts	0x03CF, r24
     d2a:	01 c0       	rjmp	.+2      	; 0xd2e <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
     d2c:	99 e0       	ldi	r25, 0x09	; 9
     d2e:	e0 91 cf 03 	lds	r30, 0x03CF
     d32:	e9 9f       	mul	r30, r25
     d34:	f0 01       	movw	r30, r0
     d36:	11 24       	eor	r1, r1
     d38:	eb 52       	subi	r30, 0x2B	; 43
     d3a:	fc 4f       	sbci	r31, 0xFC	; 252
     d3c:	80 81       	ld	r24, Z
     d3e:	88 23       	and	r24, r24
     d40:	79 f3       	breq	.-34     	; 0xd20 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
     d42:	90 91 cf 03 	lds	r25, 0x03CF
     d46:	89 e0       	ldi	r24, 0x09	; 9
     d48:	98 9f       	mul	r25, r24
     d4a:	d0 01       	movw	r26, r0
     d4c:	11 24       	eor	r1, r1
     d4e:	ab 52       	subi	r26, 0x2B	; 43
     d50:	bc 4f       	sbci	r27, 0xFC	; 252
     d52:	11 96       	adiw	r26, 0x01	; 1
     d54:	ed 91       	ld	r30, X+
     d56:	fc 91       	ld	r31, X
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	02 80       	ldd	r0, Z+2	; 0x02
     d5c:	f3 81       	ldd	r31, Z+3	; 0x03
     d5e:	e0 2d       	mov	r30, r0
     d60:	12 96       	adiw	r26, 0x02	; 2
     d62:	fc 93       	st	X, r31
     d64:	ee 93       	st	-X, r30
     d66:	11 97       	sbiw	r26, 0x01	; 1
     d68:	cd 01       	movw	r24, r26
     d6a:	03 96       	adiw	r24, 0x03	; 3
     d6c:	e8 17       	cp	r30, r24
     d6e:	f9 07       	cpc	r31, r25
     d70:	31 f4       	brne	.+12     	; 0xd7e <vTaskSwitchContext+0x6e>
     d72:	82 81       	ldd	r24, Z+2	; 0x02
     d74:	93 81       	ldd	r25, Z+3	; 0x03
     d76:	12 96       	adiw	r26, 0x02	; 2
     d78:	9c 93       	st	X, r25
     d7a:	8e 93       	st	-X, r24
     d7c:	11 97       	sbiw	r26, 0x01	; 1
     d7e:	11 96       	adiw	r26, 0x01	; 1
     d80:	ed 91       	ld	r30, X+
     d82:	fc 91       	ld	r31, X
     d84:	12 97       	sbiw	r26, 0x02	; 2
     d86:	86 81       	ldd	r24, Z+6	; 0x06
     d88:	97 81       	ldd	r25, Z+7	; 0x07
     d8a:	90 93 c9 03 	sts	0x03C9, r25
     d8e:	80 93 c8 03 	sts	0x03C8, r24
     d92:	08 95       	ret

00000d94 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
     d94:	fc 01       	movw	r30, r24
    pxTimeOut->xOverflowCount = xNumOfOverflows;
     d96:	80 91 cb 03 	lds	r24, 0x03CB
     d9a:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
     d9c:	80 91 cc 03 	lds	r24, 0x03CC
     da0:	90 91 cd 03 	lds	r25, 0x03CD
     da4:	92 83       	std	Z+2, r25	; 0x02
     da6:	81 83       	std	Z+1, r24	; 0x01
}
     da8:	08 95       	ret

00000daa <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
     daa:	fc 01       	movw	r30, r24
     dac:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
     dae:	0f b6       	in	r0, 0x3f	; 63
     db0:	f8 94       	cli
     db2:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
     db4:	4d 91       	ld	r20, X+
     db6:	5c 91       	ld	r21, X
     db8:	11 97       	sbiw	r26, 0x01	; 1
     dba:	8f ef       	ldi	r24, 0xFF	; 255
     dbc:	4f 3f       	cpi	r20, 0xFF	; 255
     dbe:	58 07       	cpc	r21, r24
     dc0:	61 f1       	breq	.+88     	; 0xe1a <xTaskCheckForTimeOut+0x70>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xTickCount >= pxTimeOut->xTimeOnEntering ) )
     dc2:	90 91 cb 03 	lds	r25, 0x03CB
     dc6:	80 81       	ld	r24, Z
     dc8:	98 17       	cp	r25, r24
     dca:	49 f0       	breq	.+18     	; 0xdde <xTaskCheckForTimeOut+0x34>
     dcc:	20 91 cc 03 	lds	r18, 0x03CC
     dd0:	30 91 cd 03 	lds	r19, 0x03CD
     dd4:	81 81       	ldd	r24, Z+1	; 0x01
     dd6:	92 81       	ldd	r25, Z+2	; 0x02
     dd8:	28 17       	cp	r18, r24
     dda:	39 07       	cpc	r19, r25
     ddc:	00 f5       	brcc	.+64     	; 0xe1e <xTaskCheckForTimeOut+0x74>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
     dde:	80 91 cc 03 	lds	r24, 0x03CC
     de2:	90 91 cd 03 	lds	r25, 0x03CD
     de6:	21 81       	ldd	r18, Z+1	; 0x01
     de8:	32 81       	ldd	r19, Z+2	; 0x02
     dea:	82 1b       	sub	r24, r18
     dec:	93 0b       	sbc	r25, r19
     dee:	84 17       	cp	r24, r20
     df0:	95 07       	cpc	r25, r21
     df2:	a8 f4       	brcc	.+42     	; 0xe1e <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xTickCount - pxTimeOut->xTimeOnEntering );
     df4:	80 91 cc 03 	lds	r24, 0x03CC
     df8:	90 91 cd 03 	lds	r25, 0x03CD
     dfc:	28 1b       	sub	r18, r24
     dfe:	39 0b       	sbc	r19, r25
     e00:	24 0f       	add	r18, r20
     e02:	35 1f       	adc	r19, r21
     e04:	2d 93       	st	X+, r18
     e06:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    pxTimeOut->xOverflowCount = xNumOfOverflows;
     e08:	80 91 cb 03 	lds	r24, 0x03CB
     e0c:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
     e0e:	80 91 cc 03 	lds	r24, 0x03CC
     e12:	90 91 cd 03 	lds	r25, 0x03CD
     e16:	92 83       	std	Z+2, r25	; 0x02
     e18:	81 83       	std	Z+1, r24	; 0x01
     e1a:	80 e0       	ldi	r24, 0x00	; 0
     e1c:	01 c0       	rjmp	.+2      	; 0xe20 <xTaskCheckForTimeOut+0x76>
     e1e:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
     e20:	0f 90       	pop	r0
     e22:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
     e24:	08 95       	ret

00000e26 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
     e26:	81 e0       	ldi	r24, 0x01	; 1
     e28:	80 93 ca 03 	sts	0x03CA, r24
}
     e2c:	08 95       	ret

00000e2e <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     e2e:	0f 93       	push	r16
     e30:	1f 93       	push	r17
     e32:	cf 93       	push	r28
     e34:	df 93       	push	r29
     e36:	fc 01       	movw	r30, r24
	it to the ready list.
	
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     e38:	80 81       	ld	r24, Z
     e3a:	88 23       	and	r24, r24
     e3c:	19 f4       	brne	.+6      	; 0xe44 <xTaskRemoveFromEventList+0x16>
     e3e:	c0 e0       	ldi	r28, 0x00	; 0
     e40:	d0 e0       	ldi	r29, 0x00	; 0
     e42:	05 c0       	rjmp	.+10     	; 0xe4e <xTaskRemoveFromEventList+0x20>
     e44:	05 80       	ldd	r0, Z+5	; 0x05
     e46:	f6 81       	ldd	r31, Z+6	; 0x06
     e48:	e0 2d       	mov	r30, r0
     e4a:	c6 81       	ldd	r28, Z+6	; 0x06
     e4c:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
     e4e:	8e 01       	movw	r16, r28
     e50:	04 5f       	subi	r16, 0xF4	; 244
     e52:	1f 4f       	sbci	r17, 0xFF	; 255
     e54:	c8 01       	movw	r24, r16
     e56:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     e5a:	80 91 ce 03 	lds	r24, 0x03CE
     e5e:	88 23       	and	r24, r24
     e60:	a1 f4       	brne	.+40     	; 0xe8a <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
     e62:	8e 01       	movw	r16, r28
     e64:	0e 5f       	subi	r16, 0xFE	; 254
     e66:	1f 4f       	sbci	r17, 0xFF	; 255
     e68:	c8 01       	movw	r24, r16
     e6a:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
     e6e:	9e 89       	ldd	r25, Y+22	; 0x16
     e70:	80 91 cf 03 	lds	r24, 0x03CF
     e74:	89 17       	cp	r24, r25
     e76:	10 f4       	brcc	.+4      	; 0xe7c <xTaskRemoveFromEventList+0x4e>
     e78:	90 93 cf 03 	sts	0x03CF, r25
     e7c:	89 e0       	ldi	r24, 0x09	; 9
     e7e:	98 9f       	mul	r25, r24
     e80:	c0 01       	movw	r24, r0
     e82:	11 24       	eor	r1, r1
     e84:	8b 52       	subi	r24, 0x2B	; 43
     e86:	9c 4f       	sbci	r25, 0xFC	; 252
     e88:	02 c0       	rjmp	.+4      	; 0xe8e <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     e8a:	8f e0       	ldi	r24, 0x0F	; 15
     e8c:	94 e0       	ldi	r25, 0x04	; 4
     e8e:	b8 01       	movw	r22, r16
     e90:	0e 94 94 00 	call	0x128	; 0x128 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
     e94:	e0 91 c8 03 	lds	r30, 0x03C8
     e98:	f0 91 c9 03 	lds	r31, 0x03C9
     e9c:	20 e0       	ldi	r18, 0x00	; 0
     e9e:	9e 89       	ldd	r25, Y+22	; 0x16
     ea0:	86 89       	ldd	r24, Z+22	; 0x16
     ea2:	98 17       	cp	r25, r24
     ea4:	08 f0       	brcs	.+2      	; 0xea8 <xTaskRemoveFromEventList+0x7a>
     ea6:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     ea8:	82 2f       	mov	r24, r18
     eaa:	df 91       	pop	r29
     eac:	cf 91       	pop	r28
     eae:	1f 91       	pop	r17
     eb0:	0f 91       	pop	r16
     eb2:	08 95       	ret

00000eb4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
     eb4:	ff 92       	push	r15
     eb6:	0f 93       	push	r16
     eb8:	1f 93       	push	r17
     eba:	cf 93       	push	r28
     ebc:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     ebe:	80 91 ce 03 	lds	r24, 0x03CE
     ec2:	88 23       	and	r24, r24
     ec4:	09 f0       	breq	.+2      	; 0xec8 <vTaskIncrementTick+0x14>
     ec6:	61 c0       	rjmp	.+194    	; 0xf8a <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
     ec8:	80 91 cc 03 	lds	r24, 0x03CC
     ecc:	90 91 cd 03 	lds	r25, 0x03CD
     ed0:	01 96       	adiw	r24, 0x01	; 1
     ed2:	90 93 cd 03 	sts	0x03CD, r25
     ed6:	80 93 cc 03 	sts	0x03CC, r24
		if( xTickCount == ( portTickType ) 0 )
     eda:	80 91 cc 03 	lds	r24, 0x03CC
     ede:	90 91 cd 03 	lds	r25, 0x03CD
     ee2:	89 2b       	or	r24, r25
     ee4:	e9 f5       	brne	.+122    	; 0xf60 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
     ee6:	80 91 0b 04 	lds	r24, 0x040B
     eea:	90 91 0c 04 	lds	r25, 0x040C
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     eee:	20 91 0d 04 	lds	r18, 0x040D
     ef2:	30 91 0e 04 	lds	r19, 0x040E
     ef6:	30 93 0c 04 	sts	0x040C, r19
     efa:	20 93 0b 04 	sts	0x040B, r18
			pxOverflowDelayedTaskList = pxTemp;
     efe:	90 93 0e 04 	sts	0x040E, r25
     f02:	80 93 0d 04 	sts	0x040D, r24
            xNumOfOverflows++;
     f06:	80 91 cb 03 	lds	r24, 0x03CB
     f0a:	8f 5f       	subi	r24, 0xFF	; 255
     f0c:	80 93 cb 03 	sts	0x03CB, r24
     f10:	27 c0       	rjmp	.+78     	; 0xf60 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     f12:	20 91 cc 03 	lds	r18, 0x03CC
     f16:	30 91 cd 03 	lds	r19, 0x03CD
     f1a:	8a 81       	ldd	r24, Y+2	; 0x02
     f1c:	9b 81       	ldd	r25, Y+3	; 0x03
     f1e:	28 17       	cp	r18, r24
     f20:	39 07       	cpc	r19, r25
     f22:	c0 f1       	brcs	.+112    	; 0xf94 <vTaskIncrementTick+0xe0>
     f24:	8e 01       	movw	r16, r28
     f26:	0e 5f       	subi	r16, 0xFE	; 254
     f28:	1f 4f       	sbci	r17, 0xFF	; 255
     f2a:	c8 01       	movw	r24, r16
     f2c:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>
     f30:	8c 89       	ldd	r24, Y+20	; 0x14
     f32:	9d 89       	ldd	r25, Y+21	; 0x15
     f34:	89 2b       	or	r24, r25
     f36:	21 f0       	breq	.+8      	; 0xf40 <vTaskIncrementTick+0x8c>
     f38:	ce 01       	movw	r24, r28
     f3a:	0c 96       	adiw	r24, 0x0c	; 12
     f3c:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>
     f40:	9e 89       	ldd	r25, Y+22	; 0x16
     f42:	80 91 cf 03 	lds	r24, 0x03CF
     f46:	89 17       	cp	r24, r25
     f48:	10 f4       	brcc	.+4      	; 0xf4e <vTaskIncrementTick+0x9a>
     f4a:	90 93 cf 03 	sts	0x03CF, r25
     f4e:	9f 9d       	mul	r25, r15
     f50:	c0 01       	movw	r24, r0
     f52:	11 24       	eor	r1, r1
     f54:	8b 52       	subi	r24, 0x2B	; 43
     f56:	9c 4f       	sbci	r25, 0xFC	; 252
     f58:	b8 01       	movw	r22, r16
     f5a:	0e 94 94 00 	call	0x128	; 0x128 <vListInsertEnd>
     f5e:	02 c0       	rjmp	.+4      	; 0xf64 <vTaskIncrementTick+0xb0>
     f60:	89 e0       	ldi	r24, 0x09	; 9
     f62:	f8 2e       	mov	r15, r24
     f64:	e0 91 0b 04 	lds	r30, 0x040B
     f68:	f0 91 0c 04 	lds	r31, 0x040C
     f6c:	80 81       	ld	r24, Z
     f6e:	88 23       	and	r24, r24
     f70:	89 f0       	breq	.+34     	; 0xf94 <vTaskIncrementTick+0xe0>
     f72:	e0 91 0b 04 	lds	r30, 0x040B
     f76:	f0 91 0c 04 	lds	r31, 0x040C
     f7a:	05 80       	ldd	r0, Z+5	; 0x05
     f7c:	f6 81       	ldd	r31, Z+6	; 0x06
     f7e:	e0 2d       	mov	r30, r0
     f80:	c6 81       	ldd	r28, Z+6	; 0x06
     f82:	d7 81       	ldd	r29, Z+7	; 0x07
     f84:	20 97       	sbiw	r28, 0x00	; 0
     f86:	29 f6       	brne	.-118    	; 0xf12 <vTaskIncrementTick+0x5e>
     f88:	05 c0       	rjmp	.+10     	; 0xf94 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
     f8a:	80 91 d0 03 	lds	r24, 0x03D0
     f8e:	8f 5f       	subi	r24, 0xFF	; 255
     f90:	80 93 d0 03 	sts	0x03D0, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
     f94:	df 91       	pop	r29
     f96:	cf 91       	pop	r28
     f98:	1f 91       	pop	r17
     f9a:	0f 91       	pop	r16
     f9c:	ff 90       	pop	r15
     f9e:	08 95       	ret

00000fa0 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
     fa0:	df 92       	push	r13
     fa2:	ef 92       	push	r14
     fa4:	ff 92       	push	r15
     fa6:	0f 93       	push	r16
     fa8:	1f 93       	push	r17
     faa:	cf 93       	push	r28
     fac:	df 93       	push	r29
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;
     fae:	ec 01       	movw	r28, r24
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
     fb0:	8a 85       	ldd	r24, Y+10	; 0x0a
     fb2:	9b 85       	ldd	r25, Y+11	; 0x0b
     fb4:	81 52       	subi	r24, 0x21	; 33
     fb6:	94 40       	sbci	r25, 0x04	; 4
     fb8:	91 f5       	brne	.+100    	; 0x101e <xTaskResumeFromISR+0x7e>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
     fba:	8c 89       	ldd	r24, Y+20	; 0x14
     fbc:	9d 89       	ldd	r25, Y+21	; 0x15
     fbe:	24 e0       	ldi	r18, 0x04	; 4
     fc0:	8f 30       	cpi	r24, 0x0F	; 15
     fc2:	92 07       	cpc	r25, r18
     fc4:	61 f1       	breq	.+88     	; 0x101e <xTaskResumeFromISR+0x7e>
			{			
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
     fc6:	89 2b       	or	r24, r25
     fc8:	51 f5       	brne	.+84     	; 0x101e <xTaskResumeFromISR+0x7e>
     fca:	33 c0       	rjmp	.+102    	; 0x1032 <xTaskResumeFromISR+0x92>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     fcc:	de 88       	ldd	r13, Y+22	; 0x16
     fce:	e0 91 c8 03 	lds	r30, 0x03C8
     fd2:	f0 91 c9 03 	lds	r31, 0x03C9
     fd6:	06 89       	ldd	r16, Z+22	; 0x16
				vListRemove(  &( pxTCB->xGenericListItem ) );	
     fd8:	92 e0       	ldi	r25, 0x02	; 2
     fda:	e9 2e       	mov	r14, r25
     fdc:	f1 2c       	mov	r15, r1
     fde:	ec 0e       	add	r14, r28
     fe0:	fd 1e       	adc	r15, r29
     fe2:	c7 01       	movw	r24, r14
     fe4:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
     fe8:	6e 89       	ldd	r22, Y+22	; 0x16
     fea:	80 91 cf 03 	lds	r24, 0x03CF
     fee:	86 17       	cp	r24, r22
     ff0:	10 f4       	brcc	.+4      	; 0xff6 <xTaskResumeFromISR+0x56>
     ff2:	60 93 cf 03 	sts	0x03CF, r22
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
     ff6:	10 e0       	ldi	r17, 0x00	; 0
     ff8:	d0 16       	cp	r13, r16
     ffa:	08 f0       	brcs	.+2      	; 0xffe <xTaskResumeFromISR+0x5e>
     ffc:	11 e0       	ldi	r17, 0x01	; 1
				vListRemove(  &( pxTCB->xGenericListItem ) );	
				prvAddTaskToReadyQueue( pxTCB );
     ffe:	89 e0       	ldi	r24, 0x09	; 9
    1000:	68 9f       	mul	r22, r24
    1002:	c0 01       	movw	r24, r0
    1004:	11 24       	eor	r1, r1
    1006:	8b 52       	subi	r24, 0x2B	; 43
    1008:	9c 4f       	sbci	r25, 0xFC	; 252
    100a:	b7 01       	movw	r22, r14
    100c:	0e 94 94 00 	call	0x128	; 0x128 <vListInsertEnd>
    1010:	07 c0       	rjmp	.+14     	; 0x1020 <xTaskResumeFromISR+0x80>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1012:	2c 96       	adiw	r28, 0x0c	; 12
    1014:	8f e0       	ldi	r24, 0x0F	; 15
    1016:	94 e0       	ldi	r25, 0x04	; 4
    1018:	be 01       	movw	r22, r28
    101a:	0e 94 94 00 	call	0x128	; 0x128 <vListInsertEnd>
    101e:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		return xYieldRequired;
	}
    1020:	81 2f       	mov	r24, r17
    1022:	df 91       	pop	r29
    1024:	cf 91       	pop	r28
    1026:	1f 91       	pop	r17
    1028:	0f 91       	pop	r16
    102a:	ff 90       	pop	r15
    102c:	ef 90       	pop	r14
    102e:	df 90       	pop	r13
    1030:	08 95       	ret

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1032:	80 91 ce 03 	lds	r24, 0x03CE
    1036:	88 23       	and	r24, r24
    1038:	49 f2       	breq	.-110    	; 0xfcc <xTaskResumeFromISR+0x2c>
    103a:	eb cf       	rjmp	.-42     	; 0x1012 <xTaskResumeFromISR+0x72>

0000103c <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    103c:	cf 93       	push	r28
    103e:	df 93       	push	r29
    1040:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1042:	60 91 c8 03 	lds	r22, 0x03C8
    1046:	70 91 c9 03 	lds	r23, 0x03C9
    104a:	64 5f       	subi	r22, 0xF4	; 244
    104c:	7f 4f       	sbci	r23, 0xFF	; 255
    104e:	0e 94 bd 00 	call	0x17a	; 0x17a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1052:	80 91 c8 03 	lds	r24, 0x03C8
    1056:	90 91 c9 03 	lds	r25, 0x03C9
    105a:	02 96       	adiw	r24, 0x02	; 2
    105c:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{			
		if( xTicksToWait == portMAX_DELAY )
    1060:	8f ef       	ldi	r24, 0xFF	; 255
    1062:	cf 3f       	cpi	r28, 0xFF	; 255
    1064:	d8 07       	cpc	r29, r24
    1066:	59 f4       	brne	.+22     	; 0x107e <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1068:	60 91 c8 03 	lds	r22, 0x03C8
    106c:	70 91 c9 03 	lds	r23, 0x03C9
    1070:	6e 5f       	subi	r22, 0xFE	; 254
    1072:	7f 4f       	sbci	r23, 0xFF	; 255
    1074:	81 e2       	ldi	r24, 0x21	; 33
    1076:	94 e0       	ldi	r25, 0x04	; 4
    1078:	0e 94 94 00 	call	0x128	; 0x128 <vListInsertEnd>
    107c:	24 c0       	rjmp	.+72     	; 0x10c6 <vTaskPlaceOnEventList+0x8a>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    107e:	80 91 cc 03 	lds	r24, 0x03CC
    1082:	90 91 cd 03 	lds	r25, 0x03CD
    1086:	8c 0f       	add	r24, r28
    1088:	9d 1f       	adc	r25, r29
		
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    108a:	e0 91 c8 03 	lds	r30, 0x03C8
    108e:	f0 91 c9 03 	lds	r31, 0x03C9
    1092:	93 83       	std	Z+3, r25	; 0x03
    1094:	82 83       	std	Z+2, r24	; 0x02
		
			if( xTimeToWake < xTickCount )
    1096:	20 91 cc 03 	lds	r18, 0x03CC
    109a:	30 91 cd 03 	lds	r19, 0x03CD
    109e:	82 17       	cp	r24, r18
    10a0:	93 07       	cpc	r25, r19
    10a2:	28 f4       	brcc	.+10     	; 0x10ae <vTaskPlaceOnEventList+0x72>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    10a4:	80 91 0d 04 	lds	r24, 0x040D
    10a8:	90 91 0e 04 	lds	r25, 0x040E
    10ac:	04 c0       	rjmp	.+8      	; 0x10b6 <vTaskPlaceOnEventList+0x7a>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    10ae:	80 91 0b 04 	lds	r24, 0x040B
    10b2:	90 91 0c 04 	lds	r25, 0x040C
    10b6:	60 91 c8 03 	lds	r22, 0x03C8
    10ba:	70 91 c9 03 	lds	r23, 0x03C9
    10be:	6e 5f       	subi	r22, 0xFE	; 254
    10c0:	7f 4f       	sbci	r23, 0xFF	; 255
    10c2:	0e 94 bd 00 	call	0x17a	; 0x17a <vListInsert>
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    10c6:	df 91       	pop	r29
    10c8:	cf 91       	pop	r28
    10ca:	08 95       	ret

000010cc <xTaskResumeAll>:
	portEXIT_CRITICAL();
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    10cc:	cf 92       	push	r12
    10ce:	df 92       	push	r13
    10d0:	ff 92       	push	r15
    10d2:	0f 93       	push	r16
    10d4:	1f 93       	push	r17
    10d6:	df 93       	push	r29
    10d8:	cf 93       	push	r28
    10da:	0f 92       	push	r0
    10dc:	cd b7       	in	r28, 0x3d	; 61
    10de:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    10e0:	0f b6       	in	r0, 0x3f	; 63
    10e2:	f8 94       	cli
    10e4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    10e6:	80 91 ce 03 	lds	r24, 0x03CE
    10ea:	81 50       	subi	r24, 0x01	; 1
    10ec:	80 93 ce 03 	sts	0x03CE, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    10f0:	80 91 ce 03 	lds	r24, 0x03CE
    10f4:	88 23       	and	r24, r24
    10f6:	09 f0       	breq	.+2      	; 0x10fa <xTaskResumeAll+0x2e>
    10f8:	5b c0       	rjmp	.+182    	; 0x11b0 <xTaskResumeAll+0xe4>
		{			
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    10fa:	80 91 d1 03 	lds	r24, 0x03D1
    10fe:	88 23       	and	r24, r24
    1100:	09 f4       	brne	.+2      	; 0x1104 <xTaskResumeAll+0x38>
    1102:	56 c0       	rjmp	.+172    	; 0x11b0 <xTaskResumeAll+0xe4>
    1104:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1106:	29 e0       	ldi	r18, 0x09	; 9
    1108:	f2 2e       	mov	r15, r18
    110a:	27 c0       	rjmp	.+78     	; 0x115a <xTaskResumeAll+0x8e>
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    110c:	c6 01       	movw	r24, r12
    110e:	0c 96       	adiw	r24, 0x0c	; 12
    1110:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1114:	86 01       	movw	r16, r12
    1116:	0e 5f       	subi	r16, 0xFE	; 254
    1118:	1f 4f       	sbci	r17, 0xFF	; 255
    111a:	c8 01       	movw	r24, r16
    111c:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1120:	d6 01       	movw	r26, r12
    1122:	56 96       	adiw	r26, 0x16	; 22
    1124:	9c 91       	ld	r25, X
    1126:	80 91 cf 03 	lds	r24, 0x03CF
    112a:	89 17       	cp	r24, r25
    112c:	10 f4       	brcc	.+4      	; 0x1132 <xTaskResumeAll+0x66>
    112e:	90 93 cf 03 	sts	0x03CF, r25
    1132:	9f 9d       	mul	r25, r15
    1134:	c0 01       	movw	r24, r0
    1136:	11 24       	eor	r1, r1
    1138:	8b 52       	subi	r24, 0x2B	; 43
    113a:	9c 4f       	sbci	r25, 0xFC	; 252
    113c:	b8 01       	movw	r22, r16
    113e:	0e 94 94 00 	call	0x128	; 0x128 <vListInsertEnd>
					
					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1142:	e0 91 c8 03 	lds	r30, 0x03C8
    1146:	f0 91 c9 03 	lds	r31, 0x03C9
    114a:	d6 01       	movw	r26, r12
    114c:	56 96       	adiw	r26, 0x16	; 22
    114e:	9c 91       	ld	r25, X
    1150:	86 89       	ldd	r24, Z+22	; 0x16
    1152:	98 17       	cp	r25, r24
    1154:	10 f0       	brcs	.+4      	; 0x115a <xTaskResumeAll+0x8e>
    1156:	b1 e0       	ldi	r27, 0x01	; 1
    1158:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    115a:	80 91 0f 04 	lds	r24, 0x040F
    115e:	88 23       	and	r24, r24
    1160:	49 f0       	breq	.+18     	; 0x1174 <xTaskResumeAll+0xa8>
    1162:	e0 91 14 04 	lds	r30, 0x0414
    1166:	f0 91 15 04 	lds	r31, 0x0415
    116a:	c6 80       	ldd	r12, Z+6	; 0x06
    116c:	d7 80       	ldd	r13, Z+7	; 0x07
    116e:	c1 14       	cp	r12, r1
    1170:	d1 04       	cpc	r13, r1
    1172:	61 f6       	brne	.-104    	; 0x110c <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1174:	80 91 d0 03 	lds	r24, 0x03D0
    1178:	88 23       	and	r24, r24
    117a:	41 f4       	brne	.+16     	; 0x118c <xTaskResumeAll+0xc0>
    117c:	0c c0       	rjmp	.+24     	; 0x1196 <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    117e:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <vTaskIncrementTick>
						--uxMissedTicks;
    1182:	80 91 d0 03 	lds	r24, 0x03D0
    1186:	81 50       	subi	r24, 0x01	; 1
    1188:	80 93 d0 03 	sts	0x03D0, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    118c:	80 91 d0 03 	lds	r24, 0x03D0
    1190:	88 23       	and	r24, r24
    1192:	a9 f7       	brne	.-22     	; 0x117e <xTaskResumeAll+0xb2>
    1194:	07 c0       	rjmp	.+14     	; 0x11a4 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}
				
				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1196:	e9 81       	ldd	r30, Y+1	; 0x01
    1198:	e1 30       	cpi	r30, 0x01	; 1
    119a:	21 f0       	breq	.+8      	; 0x11a4 <xTaskResumeAll+0xd8>
    119c:	80 91 ca 03 	lds	r24, 0x03CA
    11a0:	81 30       	cpi	r24, 0x01	; 1
    11a2:	31 f4       	brne	.+12     	; 0x11b0 <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    11a4:	10 92 ca 03 	sts	0x03CA, r1
					taskYIELD();
    11a8:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	01 c0       	rjmp	.+2      	; 0x11b2 <xTaskResumeAll+0xe6>
    11b0:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    11b2:	0f 90       	pop	r0
    11b4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    11b6:	0f 90       	pop	r0
    11b8:	cf 91       	pop	r28
    11ba:	df 91       	pop	r29
    11bc:	1f 91       	pop	r17
    11be:	0f 91       	pop	r16
    11c0:	ff 90       	pop	r15
    11c2:	df 90       	pop	r13
    11c4:	cf 90       	pop	r12
    11c6:	08 95       	ret

000011c8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    11c8:	0f 93       	push	r16
    11ca:	1f 93       	push	r17
    11cc:	cf 93       	push	r28
    11ce:	df 93       	push	r29
	tskTCB *pxTCB;

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    11d0:	ec 01       	movw	r28, r24

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    11d2:	00 97       	sbiw	r24, 0x00	; 0
    11d4:	09 f4       	brne	.+2      	; 0x11d8 <vTaskResume+0x10>
    11d6:	3c c0       	rjmp	.+120    	; 0x1250 <vTaskResume+0x88>
    11d8:	80 91 c8 03 	lds	r24, 0x03C8
    11dc:	90 91 c9 03 	lds	r25, 0x03C9
    11e0:	c8 17       	cp	r28, r24
    11e2:	d9 07       	cpc	r29, r25
    11e4:	a9 f1       	breq	.+106    	; 0x1250 <vTaskResume+0x88>
		{
			taskENTER_CRITICAL();
    11e6:	0f b6       	in	r0, 0x3f	; 63
    11e8:	f8 94       	cli
    11ea:	0f 92       	push	r0
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    11ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    11ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    11f0:	81 52       	subi	r24, 0x21	; 33
    11f2:	94 40       	sbci	r25, 0x04	; 4
    11f4:	f1 f4       	brne	.+60     	; 0x1232 <vTaskResume+0x6a>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    11f6:	8c 89       	ldd	r24, Y+20	; 0x14
    11f8:	9d 89       	ldd	r25, Y+21	; 0x15
    11fa:	24 e0       	ldi	r18, 0x04	; 4
    11fc:	8f 30       	cpi	r24, 0x0F	; 15
    11fe:	92 07       	cpc	r25, r18
    1200:	c1 f0       	breq	.+48     	; 0x1232 <vTaskResume+0x6a>
			{			
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    1202:	89 2b       	or	r24, r25
    1204:	b1 f4       	brne	.+44     	; 0x1232 <vTaskResume+0x6a>
    1206:	18 c0       	rjmp	.+48     	; 0x1238 <vTaskResume+0x70>
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1208:	90 93 cf 03 	sts	0x03CF, r25
    120c:	89 e0       	ldi	r24, 0x09	; 9
    120e:	98 9f       	mul	r25, r24
    1210:	c0 01       	movw	r24, r0
    1212:	11 24       	eor	r1, r1
    1214:	8b 52       	subi	r24, 0x2B	; 43
    1216:	9c 4f       	sbci	r25, 0xFC	; 252
    1218:	b8 01       	movw	r22, r16
    121a:	0e 94 94 00 	call	0x128	; 0x128 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    121e:	e0 91 c8 03 	lds	r30, 0x03C8
    1222:	f0 91 c9 03 	lds	r31, 0x03C9
    1226:	9e 89       	ldd	r25, Y+22	; 0x16
    1228:	86 89       	ldd	r24, Z+22	; 0x16
    122a:	98 17       	cp	r25, r24
    122c:	10 f0       	brcs	.+4      	; 0x1232 <vTaskResume+0x6a>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						taskYIELD();
    122e:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    1232:	0f 90       	pop	r0
    1234:	0f be       	out	0x3f, r0	; 63
    1236:	0c c0       	rjmp	.+24     	; 0x1250 <vTaskResume+0x88>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    1238:	8e 01       	movw	r16, r28
    123a:	0e 5f       	subi	r16, 0xFE	; 254
    123c:	1f 4f       	sbci	r17, 0xFF	; 255
    123e:	c8 01       	movw	r24, r16
    1240:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1244:	9e 89       	ldd	r25, Y+22	; 0x16
    1246:	80 91 cf 03 	lds	r24, 0x03CF
    124a:	89 17       	cp	r24, r25
    124c:	e8 f2       	brcs	.-70     	; 0x1208 <vTaskResume+0x40>
    124e:	de cf       	rjmp	.-68     	; 0x120c <vTaskResume+0x44>
					}
				}
			}
			taskEXIT_CRITICAL();
		}
	}
    1250:	df 91       	pop	r29
    1252:	cf 91       	pop	r28
    1254:	1f 91       	pop	r17
    1256:	0f 91       	pop	r16
    1258:	08 95       	ret

0000125a <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    125a:	ef 92       	push	r14
    125c:	ff 92       	push	r15
    125e:	0f 93       	push	r16
    1260:	1f 93       	push	r17
    1262:	cf 93       	push	r28
    1264:	df 93       	push	r29
    1266:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1268:	0f b6       	in	r0, 0x3f	; 63
    126a:	f8 94       	cli
    126c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    126e:	80 91 c8 03 	lds	r24, 0x03C8
    1272:	90 91 c9 03 	lds	r25, 0x03C9
    1276:	08 17       	cp	r16, r24
    1278:	19 07       	cpc	r17, r25
    127a:	19 f4       	brne	.+6      	; 0x1282 <vTaskSuspend+0x28>
    127c:	00 e0       	ldi	r16, 0x00	; 0
    127e:	10 e0       	ldi	r17, 0x00	; 0
    1280:	03 c0       	rjmp	.+6      	; 0x1288 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    1282:	01 15       	cp	r16, r1
    1284:	11 05       	cpc	r17, r1
    1286:	29 f4       	brne	.+10     	; 0x1292 <vTaskSuspend+0x38>
    1288:	c0 91 c8 03 	lds	r28, 0x03C8
    128c:	d0 91 c9 03 	lds	r29, 0x03C9
    1290:	01 c0       	rjmp	.+2      	; 0x1294 <vTaskSuspend+0x3a>
    1292:	e8 01       	movw	r28, r16

			traceTASK_SUSPEND( pxTaskToSuspend );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1294:	32 e0       	ldi	r19, 0x02	; 2
    1296:	e3 2e       	mov	r14, r19
    1298:	f1 2c       	mov	r15, r1
    129a:	ec 0e       	add	r14, r28
    129c:	fd 1e       	adc	r15, r29
    129e:	c7 01       	movw	r24, r14
    12a0:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>

			/* Is the task waiting on an event also? */												
			if( pxTCB->xEventListItem.pvContainer )
    12a4:	8c 89       	ldd	r24, Y+20	; 0x14
    12a6:	9d 89       	ldd	r25, Y+21	; 0x15
    12a8:	89 2b       	or	r24, r25
    12aa:	21 f0       	breq	.+8      	; 0x12b4 <vTaskSuspend+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    12ac:	ce 01       	movw	r24, r28
    12ae:	0c 96       	adiw	r24, 0x0c	; 12
    12b0:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    12b4:	81 e2       	ldi	r24, 0x21	; 33
    12b6:	94 e0       	ldi	r25, 0x04	; 4
    12b8:	b7 01       	movw	r22, r14
    12ba:	0e 94 94 00 	call	0x128	; 0x128 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    12be:	0f 90       	pop	r0
    12c0:	0f be       	out	0x3f, r0	; 63

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
    12c2:	01 2b       	or	r16, r17
    12c4:	11 f4       	brne	.+4      	; 0x12ca <vTaskSuspend+0x70>
		{
			taskYIELD();
    12c6:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
		}
	}
    12ca:	df 91       	pop	r29
    12cc:	cf 91       	pop	r28
    12ce:	1f 91       	pop	r17
    12d0:	0f 91       	pop	r16
    12d2:	ff 90       	pop	r15
    12d4:	ef 90       	pop	r14
    12d6:	08 95       	ret

000012d8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    12d8:	0f 93       	push	r16
    12da:	1f 93       	push	r17
    12dc:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    12de:	00 97       	sbiw	r24, 0x00	; 0
    12e0:	c9 f1       	breq	.+114    	; 0x1354 <vTaskDelay+0x7c>
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
	portENTER_CRITICAL();
    12e2:	0f b6       	in	r0, 0x3f	; 63
    12e4:	f8 94       	cli
    12e6:	0f 92       	push	r0
		++uxSchedulerSuspended;
    12e8:	80 91 ce 03 	lds	r24, 0x03CE
    12ec:	8f 5f       	subi	r24, 0xFF	; 255
    12ee:	80 93 ce 03 	sts	0x03CE, r24
	portEXIT_CRITICAL();
    12f2:	0f 90       	pop	r0
    12f4:	0f be       	out	0x3f, r0	; 63
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    12f6:	00 91 cc 03 	lds	r16, 0x03CC
    12fa:	10 91 cd 03 	lds	r17, 0x03CD
    12fe:	02 0f       	add	r16, r18
    1300:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1302:	80 91 c8 03 	lds	r24, 0x03C8
    1306:	90 91 c9 03 	lds	r25, 0x03C9
    130a:	02 96       	adiw	r24, 0x02	; 2
    130c:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1310:	e0 91 c8 03 	lds	r30, 0x03C8
    1314:	f0 91 c9 03 	lds	r31, 0x03C9
    1318:	13 83       	std	Z+3, r17	; 0x03
    131a:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    131c:	80 91 cc 03 	lds	r24, 0x03CC
    1320:	90 91 cd 03 	lds	r25, 0x03CD
    1324:	08 17       	cp	r16, r24
    1326:	19 07       	cpc	r17, r25
    1328:	28 f4       	brcc	.+10     	; 0x1334 <vTaskDelay+0x5c>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    132a:	80 91 0d 04 	lds	r24, 0x040D
    132e:	90 91 0e 04 	lds	r25, 0x040E
    1332:	04 c0       	rjmp	.+8      	; 0x133c <vTaskDelay+0x64>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1334:	80 91 0b 04 	lds	r24, 0x040B
    1338:	90 91 0c 04 	lds	r25, 0x040C
    133c:	60 91 c8 03 	lds	r22, 0x03C8
    1340:	70 91 c9 03 	lds	r23, 0x03C9
    1344:	6e 5f       	subi	r22, 0xFE	; 254
    1346:	7f 4f       	sbci	r23, 0xFF	; 255
    1348:	0e 94 bd 00 	call	0x17a	; 0x17a <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    134c:	0e 94 66 08 	call	0x10cc	; 0x10cc <xTaskResumeAll>
		}
		
		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    1350:	88 23       	and	r24, r24
    1352:	11 f4       	brne	.+4      	; 0x1358 <vTaskDelay+0x80>
		{
			taskYIELD();
    1354:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
		}
	}
    1358:	1f 91       	pop	r17
    135a:	0f 91       	pop	r16
    135c:	08 95       	ret

0000135e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    135e:	cf 93       	push	r28
    1360:	df 93       	push	r29
    1362:	fc 01       	movw	r30, r24
    1364:	eb 01       	movw	r28, r22
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
	portENTER_CRITICAL();
    1366:	0f b6       	in	r0, 0x3f	; 63
    1368:	f8 94       	cli
    136a:	0f 92       	push	r0
		++uxSchedulerSuspended;
    136c:	80 91 ce 03 	lds	r24, 0x03CE
    1370:	8f 5f       	subi	r24, 0xFF	; 255
    1372:	80 93 ce 03 	sts	0x03CE, r24
	portEXIT_CRITICAL();
    1376:	0f 90       	pop	r0
    1378:	0f be       	out	0x3f, r0	; 63
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    137a:	20 81       	ld	r18, Z
    137c:	31 81       	ldd	r19, Z+1	; 0x01
    137e:	c2 0f       	add	r28, r18
    1380:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    1382:	80 91 cc 03 	lds	r24, 0x03CC
    1386:	90 91 cd 03 	lds	r25, 0x03CD
    138a:	82 17       	cp	r24, r18
    138c:	93 07       	cpc	r25, r19
    138e:	28 f4       	brcc	.+10     	; 0x139a <vTaskDelayUntil+0x3c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1390:	c2 17       	cp	r28, r18
    1392:	d3 07       	cpc	r29, r19
    1394:	28 f0       	brcs	.+10     	; 0x13a0 <vTaskDelayUntil+0x42>
    1396:	20 e0       	ldi	r18, 0x00	; 0
    1398:	0c c0       	rjmp	.+24     	; 0x13b2 <vTaskDelayUntil+0x54>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    139a:	c2 17       	cp	r28, r18
    139c:	d3 07       	cpc	r29, r19
    139e:	40 f0       	brcs	.+16     	; 0x13b0 <vTaskDelayUntil+0x52>
    13a0:	80 91 cc 03 	lds	r24, 0x03CC
    13a4:	90 91 cd 03 	lds	r25, 0x03CD
    13a8:	20 e0       	ldi	r18, 0x00	; 0
    13aa:	8c 17       	cp	r24, r28
    13ac:	9d 07       	cpc	r25, r29
    13ae:	08 f4       	brcc	.+2      	; 0x13b2 <vTaskDelayUntil+0x54>
    13b0:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    13b2:	d1 83       	std	Z+1, r29	; 0x01
    13b4:	c0 83       	st	Z, r28

			if( xShouldDelay )
    13b6:	22 23       	and	r18, r18
    13b8:	29 f1       	breq	.+74     	; 0x1404 <vTaskDelayUntil+0xa6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    13ba:	80 91 c8 03 	lds	r24, 0x03C8
    13be:	90 91 c9 03 	lds	r25, 0x03C9
    13c2:	02 96       	adiw	r24, 0x02	; 2
    13c4:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    13c8:	e0 91 c8 03 	lds	r30, 0x03C8
    13cc:	f0 91 c9 03 	lds	r31, 0x03C9
    13d0:	d3 83       	std	Z+3, r29	; 0x03
    13d2:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    13d4:	80 91 cc 03 	lds	r24, 0x03CC
    13d8:	90 91 cd 03 	lds	r25, 0x03CD
    13dc:	c8 17       	cp	r28, r24
    13de:	d9 07       	cpc	r29, r25
    13e0:	28 f4       	brcc	.+10     	; 0x13ec <vTaskDelayUntil+0x8e>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    13e2:	80 91 0d 04 	lds	r24, 0x040D
    13e6:	90 91 0e 04 	lds	r25, 0x040E
    13ea:	04 c0       	rjmp	.+8      	; 0x13f4 <vTaskDelayUntil+0x96>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    13ec:	80 91 0b 04 	lds	r24, 0x040B
    13f0:	90 91 0c 04 	lds	r25, 0x040C
    13f4:	60 91 c8 03 	lds	r22, 0x03C8
    13f8:	70 91 c9 03 	lds	r23, 0x03C9
    13fc:	6e 5f       	subi	r22, 0xFE	; 254
    13fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1400:	0e 94 bd 00 	call	0x17a	; 0x17a <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1404:	0e 94 66 08 	call	0x10cc	; 0x10cc <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    1408:	88 23       	and	r24, r24
    140a:	11 f4       	brne	.+4      	; 0x1410 <vTaskDelayUntil+0xb2>
		{
			taskYIELD();
    140c:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
		}
	}	
    1410:	df 91       	pop	r29
    1412:	cf 91       	pop	r28
    1414:	08 95       	ret

00001416 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1416:	ef 92       	push	r14
    1418:	ff 92       	push	r15
    141a:	0f 93       	push	r16
    141c:	1f 93       	push	r17
    141e:	cf 93       	push	r28
    1420:	df 93       	push	r29
    1422:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1424:	0f b6       	in	r0, 0x3f	; 63
    1426:	f8 94       	cli
    1428:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    142a:	80 91 c8 03 	lds	r24, 0x03C8
    142e:	90 91 c9 03 	lds	r25, 0x03C9
    1432:	08 17       	cp	r16, r24
    1434:	19 07       	cpc	r17, r25
    1436:	19 f4       	brne	.+6      	; 0x143e <vTaskDelete+0x28>
    1438:	00 e0       	ldi	r16, 0x00	; 0
    143a:	10 e0       	ldi	r17, 0x00	; 0
    143c:	03 c0       	rjmp	.+6      	; 0x1444 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    143e:	01 15       	cp	r16, r1
    1440:	11 05       	cpc	r17, r1
    1442:	29 f4       	brne	.+10     	; 0x144e <vTaskDelete+0x38>
    1444:	c0 91 c8 03 	lds	r28, 0x03C8
    1448:	d0 91 c9 03 	lds	r29, 0x03C9
    144c:	01 c0       	rjmp	.+2      	; 0x1450 <vTaskDelete+0x3a>
    144e:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1450:	42 e0       	ldi	r20, 0x02	; 2
    1452:	e4 2e       	mov	r14, r20
    1454:	f1 2c       	mov	r15, r1
    1456:	ec 0e       	add	r14, r28
    1458:	fd 1e       	adc	r15, r29
    145a:	c7 01       	movw	r24, r14
    145c:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>

			/* Is the task waiting on an event also? */												
			if( pxTCB->xEventListItem.pvContainer )
    1460:	8c 89       	ldd	r24, Y+20	; 0x14
    1462:	9d 89       	ldd	r25, Y+21	; 0x15
    1464:	89 2b       	or	r24, r25
    1466:	21 f0       	breq	.+8      	; 0x1470 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1468:	ce 01       	movw	r24, r28
    146a:	0c 96       	adiw	r24, 0x0c	; 12
    146c:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1470:	88 e1       	ldi	r24, 0x18	; 24
    1472:	94 e0       	ldi	r25, 0x04	; 4
    1474:	b7 01       	movw	r22, r14
    1476:	0e 94 94 00 	call	0x128	; 0x128 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    147a:	80 91 d3 03 	lds	r24, 0x03D3
    147e:	8f 5f       	subi	r24, 0xFF	; 255
    1480:	80 93 d3 03 	sts	0x03D3, r24
		}
		taskEXIT_CRITICAL();
    1484:	0f 90       	pop	r0
    1486:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1488:	80 91 d2 03 	lds	r24, 0x03D2
    148c:	88 23       	and	r24, r24
    148e:	21 f0       	breq	.+8      	; 0x1498 <vTaskDelete+0x82>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1490:	01 2b       	or	r16, r17
    1492:	11 f4       	brne	.+4      	; 0x1498 <vTaskDelete+0x82>
			{
				taskYIELD();
    1494:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
			}
		}
	}
    1498:	df 91       	pop	r29
    149a:	cf 91       	pop	r28
    149c:	1f 91       	pop	r17
    149e:	0f 91       	pop	r16
    14a0:	ff 90       	pop	r15
    14a2:	ef 90       	pop	r14
    14a4:	08 95       	ret

000014a6 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    14a6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    14a8:	10 92 d2 03 	sts	0x03D2, r1
	vPortEndScheduler();
    14ac:	0e 94 8f 02 	call	0x51e	; 0x51e <vPortEndScheduler>
}
    14b0:	08 95       	ret

000014b2 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    14b2:	1f 93       	push	r17
    14b4:	cf 93       	push	r28
    14b6:	df 93       	push	r29
	{				
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    14b8:	80 91 d3 03 	lds	r24, 0x03D3
    14bc:	88 23       	and	r24, r24
    14be:	09 f4       	brne	.+2      	; 0x14c2 <prvIdleTask+0x10>
    14c0:	37 c0       	rjmp	.+110    	; 0x1530 <prvIdleTask+0x7e>
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
	portENTER_CRITICAL();
    14c2:	0f b6       	in	r0, 0x3f	; 63
    14c4:	f8 94       	cli
    14c6:	0f 92       	push	r0
		++uxSchedulerSuspended;
    14c8:	80 91 ce 03 	lds	r24, 0x03CE
    14cc:	8f 5f       	subi	r24, 0xFF	; 255
    14ce:	80 93 ce 03 	sts	0x03CE, r24
	portEXIT_CRITICAL();
    14d2:	0f 90       	pop	r0
    14d4:	0f be       	out	0x3f, r0	; 63
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );				
    14d6:	10 91 18 04 	lds	r17, 0x0418
			xTaskResumeAll();
    14da:	0e 94 66 08 	call	0x10cc	; 0x10cc <xTaskResumeAll>

			if( !xListIsEmpty )
    14de:	11 23       	and	r17, r17
    14e0:	39 f1       	breq	.+78     	; 0x1530 <prvIdleTask+0x7e>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    14e2:	0f b6       	in	r0, 0x3f	; 63
    14e4:	f8 94       	cli
    14e6:	0f 92       	push	r0
				{			
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    14e8:	80 91 18 04 	lds	r24, 0x0418
    14ec:	88 23       	and	r24, r24
    14ee:	19 f4       	brne	.+6      	; 0x14f6 <prvIdleTask+0x44>
    14f0:	c0 e0       	ldi	r28, 0x00	; 0
    14f2:	d0 e0       	ldi	r29, 0x00	; 0
    14f4:	06 c0       	rjmp	.+12     	; 0x1502 <prvIdleTask+0x50>
    14f6:	e0 91 1d 04 	lds	r30, 0x041D
    14fa:	f0 91 1e 04 	lds	r31, 0x041E
    14fe:	c6 81       	ldd	r28, Z+6	; 0x06
    1500:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1502:	ce 01       	movw	r24, r28
    1504:	02 96       	adiw	r24, 0x02	; 2
    1506:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vListRemove>
					--uxCurrentNumberOfTasks;
    150a:	80 91 d1 03 	lds	r24, 0x03D1
    150e:	81 50       	subi	r24, 0x01	; 1
    1510:	80 93 d1 03 	sts	0x03D1, r24
					--uxTasksDeleted;
    1514:	80 91 d3 03 	lds	r24, 0x03D3
    1518:	81 50       	subi	r24, 0x01	; 1
    151a:	80 93 d3 03 	sts	0x03D3, r24
				}
				portEXIT_CRITICAL();
    151e:	0f 90       	pop	r0
    1520:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFree( pxTCB->pxStack );
    1522:	8f 89       	ldd	r24, Y+23	; 0x17
    1524:	98 8d       	ldd	r25, Y+24	; 0x18
    1526:	0e 94 53 00 	call	0xa6	; 0xa6 <vPortFree>
		vPortFree( pxTCB );
    152a:	ce 01       	movw	r24, r28
    152c:	0e 94 53 00 	call	0xa6	; 0xa6 <vPortFree>
			
			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1530:	80 91 d5 03 	lds	r24, 0x03D5
    1534:	82 30       	cpi	r24, 0x02	; 2
    1536:	08 f4       	brcc	.+2      	; 0x153a <prvIdleTask+0x88>
    1538:	bf cf       	rjmp	.-130    	; 0x14b8 <prvIdleTask+0x6>
			{
				taskYIELD();
    153a:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
    153e:	bc cf       	rjmp	.-136    	; 0x14b8 <prvIdleTask+0x6>

00001540 <xTaskCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode, const signed portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask )
{
    1540:	2f 92       	push	r2
    1542:	3f 92       	push	r3
    1544:	4f 92       	push	r4
    1546:	5f 92       	push	r5
    1548:	6f 92       	push	r6
    154a:	7f 92       	push	r7
    154c:	9f 92       	push	r9
    154e:	af 92       	push	r10
    1550:	bf 92       	push	r11
    1552:	cf 92       	push	r12
    1554:	df 92       	push	r13
    1556:	ef 92       	push	r14
    1558:	ff 92       	push	r15
    155a:	0f 93       	push	r16
    155c:	1f 93       	push	r17
    155e:	cf 93       	push	r28
    1560:	df 93       	push	r29
    1562:	2c 01       	movw	r4, r24
    1564:	5b 01       	movw	r10, r22
    1566:	6a 01       	movw	r12, r20
    1568:	39 01       	movw	r6, r18
    156a:	90 2e       	mov	r9, r16
    156c:	17 01       	movw	r2, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    156e:	81 e2       	ldi	r24, 0x21	; 33
    1570:	90 e0       	ldi	r25, 0x00	; 0
    1572:	0e 94 59 00 	call	0xb2	; 0xb2 <pvPortMalloc>
    1576:	ec 01       	movw	r28, r24

	if( pxNewTCB != NULL )
    1578:	00 97       	sbiw	r24, 0x00	; 0
    157a:	51 f0       	breq	.+20     	; 0x1590 <xTaskCreate+0x50>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMalloc( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) );
    157c:	c6 01       	movw	r24, r12
    157e:	0e 94 59 00 	call	0xb2	; 0xb2 <pvPortMalloc>
    1582:	98 8f       	std	Y+24, r25	; 0x18
    1584:	8f 8b       	std	Y+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1586:	00 97       	sbiw	r24, 0x00	; 0
    1588:	29 f4       	brne	.+10     	; 0x1594 <xTaskCreate+0x54>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );			
    158a:	ce 01       	movw	r24, r28
    158c:	0e 94 53 00 	call	0xa6	; 0xa6 <vPortFree>
    1590:	8f ef       	ldi	r24, 0xFF	; 255
    1592:	b3 c0       	rjmp	.+358    	; 0x16fa <xTaskCreate+0x1ba>
			pxNewTCB = NULL;			
		}		
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    1594:	65 ea       	ldi	r22, 0xA5	; 165
    1596:	70 e0       	ldi	r23, 0x00	; 0
    1598:	a6 01       	movw	r20, r12
    159a:	0e 94 b7 0b 	call	0x176e	; 0x176e <memset>


static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed portCHAR * const pcName, unsigned portBASE_TYPE uxPriority )
{
	/* Store the function name in the TCB. */
	strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned portSHORT ) configMAX_TASK_NAME_LEN );
    159e:	ce 01       	movw	r24, r28
    15a0:	49 96       	adiw	r24, 0x19	; 25
    15a2:	b5 01       	movw	r22, r10
    15a4:	48 e0       	ldi	r20, 0x08	; 8
    15a6:	50 e0       	ldi	r21, 0x00	; 0
    15a8:	0e 94 be 0b 	call	0x177c	; 0x177c <strncpy>
	pxTCB->pcTaskName[ ( unsigned portSHORT ) configMAX_TASK_NAME_LEN - ( unsigned portSHORT ) 1 ] = '\0';
    15ac:	18 a2       	std	Y+32, r1	; 0x20
    15ae:	83 e0       	ldi	r24, 0x03	; 3
    15b0:	89 15       	cp	r24, r9
    15b2:	08 f4       	brcc	.+2      	; 0x15b6 <xTaskCreate+0x76>
    15b4:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    15b6:	0e 8b       	std	Y+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    15b8:	62 e0       	ldi	r22, 0x02	; 2
    15ba:	a6 2e       	mov	r10, r22
    15bc:	b1 2c       	mov	r11, r1
    15be:	ac 0e       	add	r10, r28
    15c0:	bd 1e       	adc	r11, r29
    15c2:	c5 01       	movw	r24, r10
    15c4:	0e 94 90 00 	call	0x120	; 0x120 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    15c8:	ce 01       	movw	r24, r28
    15ca:	0c 96       	adiw	r24, 0x0c	; 12
    15cc:	0e 94 90 00 	call	0x120	; 0x120 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    15d0:	d9 87       	std	Y+9, r29	; 0x09
    15d2:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    15d4:	84 e0       	ldi	r24, 0x04	; 4
    15d6:	90 e0       	ldi	r25, 0x00	; 0
    15d8:	80 1b       	sub	r24, r16
    15da:	91 09       	sbc	r25, r1
    15dc:	9d 87       	std	Y+13, r25	; 0x0d
    15de:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    15e0:	db 8b       	std	Y+19, r29	; 0x13
    15e2:	ca 8b       	std	Y+18, r28	; 0x12

		/* Initialize the TCB stack to look as if the task was already running,
		but had been interrupted by the scheduler.  The return address is set
		to the start of the task function. Once the stack has been initialised
		the	top of stack variable is updated. */
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
    15e4:	08 94       	sec
    15e6:	c1 08       	sbc	r12, r1
    15e8:	d1 08       	sbc	r13, r1
    15ea:	8f 89       	ldd	r24, Y+23	; 0x17
    15ec:	98 8d       	ldd	r25, Y+24	; 0x18
    15ee:	8c 0d       	add	r24, r12
    15f0:	9d 1d       	adc	r25, r13
    15f2:	b2 01       	movw	r22, r4
    15f4:	a3 01       	movw	r20, r6
    15f6:	0e 94 0d 02 	call	0x41a	; 0x41a <pxPortInitialiseStack>
    15fa:	99 83       	std	Y+1, r25	; 0x01
    15fc:	88 83       	st	Y, r24

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    15fe:	0f b6       	in	r0, 0x3f	; 63
    1600:	f8 94       	cli
    1602:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1604:	80 91 d1 03 	lds	r24, 0x03D1
    1608:	8f 5f       	subi	r24, 0xFF	; 255
    160a:	80 93 d1 03 	sts	0x03D1, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    160e:	80 91 d1 03 	lds	r24, 0x03D1
    1612:	81 30       	cpi	r24, 0x01	; 1
    1614:	a9 f5       	brne	.+106    	; 0x1680 <xTaskCreate+0x140>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    1616:	d0 93 c9 03 	sts	0x03C9, r29
    161a:	c0 93 c8 03 	sts	0x03C8, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    161e:	85 ed       	ldi	r24, 0xD5	; 213
    1620:	93 e0       	ldi	r25, 0x03	; 3
    1622:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>
    1626:	8e ed       	ldi	r24, 0xDE	; 222
    1628:	93 e0       	ldi	r25, 0x03	; 3
    162a:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>
    162e:	87 ee       	ldi	r24, 0xE7	; 231
    1630:	93 e0       	ldi	r25, 0x03	; 3
    1632:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>
    1636:	80 ef       	ldi	r24, 0xF0	; 240
    1638:	93 e0       	ldi	r25, 0x03	; 3
    163a:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    163e:	59 ef       	ldi	r21, 0xF9	; 249
    1640:	e5 2e       	mov	r14, r21
    1642:	53 e0       	ldi	r21, 0x03	; 3
    1644:	f5 2e       	mov	r15, r21
    1646:	c7 01       	movw	r24, r14
    1648:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    164c:	02 e0       	ldi	r16, 0x02	; 2
    164e:	14 e0       	ldi	r17, 0x04	; 4
    1650:	c8 01       	movw	r24, r16
    1652:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1656:	8f e0       	ldi	r24, 0x0F	; 15
    1658:	94 e0       	ldi	r25, 0x04	; 4
    165a:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    165e:	88 e1       	ldi	r24, 0x18	; 24
    1660:	94 e0       	ldi	r25, 0x04	; 4
    1662:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    1666:	81 e2       	ldi	r24, 0x21	; 33
    1668:	94 e0       	ldi	r25, 0x04	; 4
    166a:	0e 94 80 00 	call	0x100	; 0x100 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    166e:	f0 92 0c 04 	sts	0x040C, r15
    1672:	e0 92 0b 04 	sts	0x040B, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1676:	10 93 0e 04 	sts	0x040E, r17
    167a:	00 93 0d 04 	sts	0x040D, r16
    167e:	0f c0       	rjmp	.+30     	; 0x169e <xTaskCreate+0x15e>
			else
			{	
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1680:	80 91 d2 03 	lds	r24, 0x03D2
    1684:	88 23       	and	r24, r24
    1686:	59 f4       	brne	.+22     	; 0x169e <xTaskCreate+0x15e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1688:	e0 91 c8 03 	lds	r30, 0x03C8
    168c:	f0 91 c9 03 	lds	r31, 0x03C9
    1690:	86 89       	ldd	r24, Z+22	; 0x16
    1692:	98 16       	cp	r9, r24
    1694:	20 f0       	brcs	.+8      	; 0x169e <xTaskCreate+0x15e>
					{
						pxCurrentTCB = pxNewTCB;	
    1696:	d0 93 c9 03 	sts	0x03C9, r29
    169a:	c0 93 c8 03 	sts	0x03C8, r28
				}
			}				

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    169e:	9e 89       	ldd	r25, Y+22	; 0x16
    16a0:	80 91 d4 03 	lds	r24, 0x03D4
    16a4:	89 17       	cp	r24, r25
    16a6:	10 f4       	brcc	.+4      	; 0x16ac <xTaskCreate+0x16c>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    16a8:	90 93 d4 03 	sts	0x03D4, r25
				pxNewTCB->uxTCBNumber = uxTaskNumber;
				uxTaskNumber++;
			}
			#endif

			prvAddTaskToReadyQueue( pxNewTCB );
    16ac:	9e 89       	ldd	r25, Y+22	; 0x16
    16ae:	80 91 cf 03 	lds	r24, 0x03CF
    16b2:	89 17       	cp	r24, r25
    16b4:	10 f4       	brcc	.+4      	; 0x16ba <xTaskCreate+0x17a>
    16b6:	90 93 cf 03 	sts	0x03CF, r25
    16ba:	8e 89       	ldd	r24, Y+22	; 0x16
    16bc:	29 e0       	ldi	r18, 0x09	; 9
    16be:	82 9f       	mul	r24, r18
    16c0:	c0 01       	movw	r24, r0
    16c2:	11 24       	eor	r1, r1
    16c4:	8b 52       	subi	r24, 0x2B	; 43
    16c6:	9c 4f       	sbci	r25, 0xFC	; 252
    16c8:	b5 01       	movw	r22, r10
    16ca:	0e 94 94 00 	call	0x128	; 0x128 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    16ce:	0f 90       	pop	r0
    16d0:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
    16d2:	21 14       	cp	r2, r1
    16d4:	31 04       	cpc	r3, r1
    16d6:	19 f0       	breq	.+6      	; 0x16de <xTaskCreate+0x19e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    16d8:	f1 01       	movw	r30, r2
    16da:	d1 83       	std	Z+1, r29	; 0x01
    16dc:	c0 83       	st	Z, r28
		}

		if( xSchedulerRunning != pdFALSE )
    16de:	80 91 d2 03 	lds	r24, 0x03D2
    16e2:	88 23       	and	r24, r24
    16e4:	49 f0       	breq	.+18     	; 0x16f8 <xTaskCreate+0x1b8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    16e6:	e0 91 c8 03 	lds	r30, 0x03C8
    16ea:	f0 91 c9 03 	lds	r31, 0x03C9
    16ee:	86 89       	ldd	r24, Z+22	; 0x16
    16f0:	89 15       	cp	r24, r9
    16f2:	10 f4       	brcc	.+4      	; 0x16f8 <xTaskCreate+0x1b8>
			{
				taskYIELD();
    16f4:	0e 94 ee 02 	call	0x5dc	; 0x5dc <vPortYield>
    16f8:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    16fa:	df 91       	pop	r29
    16fc:	cf 91       	pop	r28
    16fe:	1f 91       	pop	r17
    1700:	0f 91       	pop	r16
    1702:	ff 90       	pop	r15
    1704:	ef 90       	pop	r14
    1706:	df 90       	pop	r13
    1708:	cf 90       	pop	r12
    170a:	bf 90       	pop	r11
    170c:	af 90       	pop	r10
    170e:	9f 90       	pop	r9
    1710:	7f 90       	pop	r7
    1712:	6f 90       	pop	r6
    1714:	5f 90       	pop	r5
    1716:	4f 90       	pop	r4
    1718:	3f 90       	pop	r3
    171a:	2f 90       	pop	r2
    171c:	08 95       	ret

0000171e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    171e:	ef 92       	push	r14
    1720:	ff 92       	push	r15
    1722:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed portCHAR * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
    1724:	89 e5       	ldi	r24, 0x59	; 89
    1726:	9a e0       	ldi	r25, 0x0A	; 10
    1728:	66 e2       	ldi	r22, 0x26	; 38
    172a:	71 e0       	ldi	r23, 0x01	; 1
    172c:	45 e5       	ldi	r20, 0x55	; 85
    172e:	50 e0       	ldi	r21, 0x00	; 0
    1730:	20 e0       	ldi	r18, 0x00	; 0
    1732:	30 e0       	ldi	r19, 0x00	; 0
    1734:	00 e0       	ldi	r16, 0x00	; 0
    1736:	ee 24       	eor	r14, r14
    1738:	ff 24       	eor	r15, r15
    173a:	0e 94 a0 0a 	call	0x1540	; 0x1540 <xTaskCreate>

	if( xReturn == pdPASS )
    173e:	81 30       	cpi	r24, 0x01	; 1
    1740:	49 f4       	brne	.+18     	; 0x1754 <vTaskStartScheduler+0x36>
		so interrupts will automatically get re-enabled when the first task
		starts to run.
		
		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1742:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1744:	80 93 d2 03 	sts	0x03D2, r24
		xTickCount = ( portTickType ) 0;
    1748:	10 92 cd 03 	sts	0x03CD, r1
    174c:	10 92 cc 03 	sts	0x03CC, r1

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    1750:	0e 94 55 02 	call	0x4aa	; 0x4aa <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    1754:	0f 91       	pop	r16
    1756:	ff 90       	pop	r15
    1758:	ef 90       	pop	r14
    175a:	08 95       	ret

0000175c <memcpy>:
    175c:	fb 01       	movw	r30, r22
    175e:	dc 01       	movw	r26, r24
    1760:	02 c0       	rjmp	.+4      	; 0x1766 <memcpy+0xa>
    1762:	01 90       	ld	r0, Z+
    1764:	0d 92       	st	X+, r0
    1766:	41 50       	subi	r20, 0x01	; 1
    1768:	50 40       	sbci	r21, 0x00	; 0
    176a:	d8 f7       	brcc	.-10     	; 0x1762 <memcpy+0x6>
    176c:	08 95       	ret

0000176e <memset>:
    176e:	dc 01       	movw	r26, r24
    1770:	01 c0       	rjmp	.+2      	; 0x1774 <memset+0x6>
    1772:	6d 93       	st	X+, r22
    1774:	41 50       	subi	r20, 0x01	; 1
    1776:	50 40       	sbci	r21, 0x00	; 0
    1778:	e0 f7       	brcc	.-8      	; 0x1772 <memset+0x4>
    177a:	08 95       	ret

0000177c <strncpy>:
    177c:	fb 01       	movw	r30, r22
    177e:	dc 01       	movw	r26, r24
    1780:	41 50       	subi	r20, 0x01	; 1
    1782:	50 40       	sbci	r21, 0x00	; 0
    1784:	48 f0       	brcs	.+18     	; 0x1798 <strncpy+0x1c>
    1786:	01 90       	ld	r0, Z+
    1788:	0d 92       	st	X+, r0
    178a:	00 20       	and	r0, r0
    178c:	c9 f7       	brne	.-14     	; 0x1780 <strncpy+0x4>
    178e:	01 c0       	rjmp	.+2      	; 0x1792 <strncpy+0x16>
    1790:	1d 92       	st	X+, r1
    1792:	41 50       	subi	r20, 0x01	; 1
    1794:	50 40       	sbci	r21, 0x00	; 0
    1796:	e0 f7       	brcc	.-8      	; 0x1790 <strncpy+0x14>
    1798:	08 95       	ret

0000179a <__divmodhi4>:
    179a:	97 fb       	bst	r25, 7
    179c:	09 2e       	mov	r0, r25
    179e:	07 26       	eor	r0, r23
    17a0:	0a d0       	rcall	.+20     	; 0x17b6 <__divmodhi4_neg1>
    17a2:	77 fd       	sbrc	r23, 7
    17a4:	04 d0       	rcall	.+8      	; 0x17ae <__divmodhi4_neg2>
    17a6:	0c d0       	rcall	.+24     	; 0x17c0 <__udivmodhi4>
    17a8:	06 d0       	rcall	.+12     	; 0x17b6 <__divmodhi4_neg1>
    17aa:	00 20       	and	r0, r0
    17ac:	1a f4       	brpl	.+6      	; 0x17b4 <__divmodhi4_exit>

000017ae <__divmodhi4_neg2>:
    17ae:	70 95       	com	r23
    17b0:	61 95       	neg	r22
    17b2:	7f 4f       	sbci	r23, 0xFF	; 255

000017b4 <__divmodhi4_exit>:
    17b4:	08 95       	ret

000017b6 <__divmodhi4_neg1>:
    17b6:	f6 f7       	brtc	.-4      	; 0x17b4 <__divmodhi4_exit>
    17b8:	90 95       	com	r25
    17ba:	81 95       	neg	r24
    17bc:	9f 4f       	sbci	r25, 0xFF	; 255
    17be:	08 95       	ret

000017c0 <__udivmodhi4>:
    17c0:	aa 1b       	sub	r26, r26
    17c2:	bb 1b       	sub	r27, r27
    17c4:	51 e1       	ldi	r21, 0x11	; 17
    17c6:	07 c0       	rjmp	.+14     	; 0x17d6 <__udivmodhi4_ep>

000017c8 <__udivmodhi4_loop>:
    17c8:	aa 1f       	adc	r26, r26
    17ca:	bb 1f       	adc	r27, r27
    17cc:	a6 17       	cp	r26, r22
    17ce:	b7 07       	cpc	r27, r23
    17d0:	10 f0       	brcs	.+4      	; 0x17d6 <__udivmodhi4_ep>
    17d2:	a6 1b       	sub	r26, r22
    17d4:	b7 0b       	sbc	r27, r23

000017d6 <__udivmodhi4_ep>:
    17d6:	88 1f       	adc	r24, r24
    17d8:	99 1f       	adc	r25, r25
    17da:	5a 95       	dec	r21
    17dc:	a9 f7       	brne	.-22     	; 0x17c8 <__udivmodhi4_loop>
    17de:	80 95       	com	r24
    17e0:	90 95       	com	r25
    17e2:	bc 01       	movw	r22, r24
    17e4:	cd 01       	movw	r24, r26
    17e6:	08 95       	ret

000017e8 <_exit>:
    17e8:	f8 94       	cli

000017ea <__stop_program>:
    17ea:	ff cf       	rjmp	.-2      	; 0x17ea <__stop_program>
